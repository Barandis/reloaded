*********

Welcome to Project 64!

  The goal of Project 64 is to preserve Commodore 64 related documents
in electronic text format that might otherwise cease to exist with the
rapid advancement of computer technology and declining interest in 8-
bit computers on the part of the general population.

  Extensive efforts were made to preserve the contents of the original
document.  However, certain portions, such as diagrams, program
listings, and indexes may have been either altered or sacrificed due
to the limitations of plain vanilla text.  Diagrams may have been
eliminated where ASCII-art was not feasible.  Program listings may be
missing display codes where substitutions were not possible.  Tables
of contents and indexes may have been changed from page number
references to section number references. Please accept our apologies
for these limitations, alterations, and possible omissions.

  The author(s) of the original document and members of Project 64 make
no representations about the accuracy or suitability of this material
for any purpose.  This etext is provided "as-is".  Please refer to the
warantee of the original document, if any, that may included in this
etext.  No other warantees, express or implied, are made to you as to
the etext or any medium it may be on.  Neither the author(s) nor the
members of Project 64 will assume liability for damages either from
the direct or indirect use of this etext or from the distribution of
or modification to this etext.  Therefore if you read this document or
use the information herein you do so at your own risk.

*********

  The Project 64 etext of Inside Commodore DOS by Richard Immers, Ph.D.
and Gerald G. Neufeld, Ph.D. second edition. Converted to etext by
Silver Dream !

INCDOS01.TXT (WIP), April 2014

*********
﻿
                              INSIDE
                             COMMODORE
                                DOS
﻿
﻿



                                INSIDE
                              COMMODORE
                                 DOS

                                  by

                        Richard Immers, Ph.D.
                        Adrian Public Schools
                          Adrian, Michigan

                                and

                      Gerald G. Neufeld, Ph.D.
                        Brandon University
                         Brandon, Manitoba
                              Canada


                    Technical Illustrations by
                        Diane M. Corralejo

                           DATAMOST, Inc.
            19821 Nordhoff Street, Northridge, CA 91324
                          (818) 709-1202
﻿



                    First Printing, July 1984
                  Second Printing, February 1985







                 RESTON PUBLISHING COMPANY, INC.
                    A Prentice-Hall Company
                       Reston, Virginia

                       ISBN 0-8359-3091-2

                Copyright © 1984 by DATAMOST, Inc.
                       All Rights Reserved

This manual is published and copyrighted by DATAMOST, Inc. All rights are
reserved by DATAMOST, Inc. Copying, duplicating, selling or otherwise
distributing this product is hereby expressly forbidden except by prior written
consent of DATAMOST, Inc.

The words COMMODORE, CBM, COMMODORE 64, VIC-20, VIC-1541 and the Commodore logo
are registered trademarks of Commodore Business Machines, Inc.

Commodore Business Machines was not in any way involved in the writing or other
preparation of this manual, nor were the facts presented here reviewed for
accuracy by them.

The information presented in this manual is the result of intensive study of
the disassembly of the 1541 DOS. Every effort has been made to provide
error-free information. However, neither the authors nor DATAMOST, Inc. can
accept responsibility for any loss or damage, tangible or intangible, resulting
from use or improper or unintended use of this information.

                                                       Printed in U.S.A.
﻿


                        ACKNOWLEDGEMENTS

A manual like this one would not be possible without a great deal of technical
assistance. Mike Todd's Disk File column in the ICPUG Newsletter proved to be
an invaluable source of insight into the inner workings of Commodore's DOS.
Raeto West's book, Programming the PET/CBM, was a constant companion. Jim
Butterfield's numerous articles also provided valuable bits and pieces of
information. Brad Templeton's POWER™ system and PAL™ assembler made the
development of the programs in this manual a real joy. These packages are
commercially available from Professional Software Inc. In addition, both the
PAL disassembler and MICROMON were used as tools for disassembling the 1541 DOS.

We would also like to acknowledge the patience and forebearance of our families
and friends. Without their support, producing this manual would have been
considerably more difficult. Mike Louder of DATAMOST, Inc. also provided
tremendous support for its production.

Finally, we would like to extend a special note of thanks to Dr. Tom MacNeil
and Nancy Neufeld for their diligent work in proofreading this manual.

This manual was written on a Commodore computer system using the WordPro 4 Plus
word processing system. The WordPro Plus™ Series is commercially available from
Professional Software Inc. This sophisticated word processing system made
editing and last minute revisions much easier.
﻿
﻿



                        TABLE OF CONTENTS

Chapter 1 - INTRODUCTION
            A Brief Word About the Programs
            How to Type in the Programs

Chapter 2 - USING THE 1541'S DOS
            The Purpose of DOS
            Communicating with the 1541
            The Command Channel
            Using the Command Channel
            Diskette Housekeeping

Chapter 3 - DISKETTE FORMATTING
            Layout of Tracks and Sectors
            Layout of a Sector
            The Header Block
            The Data Block

Chapter 4 - DISKETTE ORGANIZATION
            Information Management
            The Directory You See
            The Block Availability Map
            The Directory Entries
            Program File Storage
            Sequential File Storage
            Relative File Storage
            User File Storage
            Deleted File Storage
            Locked Files

Chapter 5 - DIRECT-ACCESS PROGRAMMING
            Introduction to Direct-Access Programming
            Beginning Direct-Access Programming
            Block-Read Command
            Buffer-Pointer Command
            Block-Write Command
            Memory-Read Command
            Memory-Write Command
            Block-Allocate Command
            Block-Free Command
            Memory-Execute Command
            Block Execute Command
            Direct-Access Entomology

Chapter 6 - INTERMEDIATE DIRECT-ACCESS PROGRAMMING

Chapter 7 - DOS PROTECTION
            Commodore's Data Encoding Scheme
            Checksums
            Description of DOS Error Messages
            Analyzing a Protected Diskette
            Duplicating a Protection Scheme
            How to Create 21 Errors on a Full Track
            How to Create a 21 Error on a Single Sector
            How to Create a 23 Error on a Single Sector
            How to Duplicate a 23 Error on a Single Sector
            How to Create 23 Errors on a Full Track
            How to Create 20 Errors on a Full Track
            How to Create 27 Errors on a Full Track
            How to Create a 22 Error on a Single Sector
            How to Duplicate a 22 Error on a Single Sector
            How to Format a Diskette with Multiple IDs
            How to Backup a DOS Protected Diskette
            How to Copy a File

Chapter 8 - GETTING OUT OF TROUBLE
            Unscratching a File
            Recovering a Soft Sector
            Recovering a Hard Sector
            Recovering a Relative File
            Recovering an Entire Diskette
            Recovering a Physically Damaged Diskette
            Recovering an Unclosed File
            Recovering from a Short New
            Recovering from a Full New

Chapter 9 - OVERVIEW OF THE 1541 DOS
            Introduction to 1541 DOS
            The Hard Working 6502
            Major IP Routines
            Using the IP Routines
            Major FDC Routines
            Using the FDC Routines
            The Recording Process
            Block Diagram of the 1541
            Writing Data to a Diskette
            Reading Data From a Diskette
            Summary Bugs in DOS 2.6
            Write Incompatibility with 4040
            Late News

Appendix A - 1541 RAM VARIABLE DEFINITIONS

Appendix B - ANALYSIS OF THE 1541's ROM

Appendix C - PROGRAM LISTINGS

Appendix D - MATHEMATICAL CONVERSION ROUTINES

Index
﻿
Ignorance is a precious thing.
Once lost, it can never be regained.
﻿
CHAPTER 1

INTRODUCTION

This manual is intended to supplement the documentation provided in the 1541
User's Manual. Although this manual is primarily designed to meet the needs of
the intermediate to advanced programmer, it will also be of interest to the
novice Commodore user who wants to know more about how his 1541 disk drive
works. This manual is not intended to replace the documentation provided by
Commodore Business Machines, Inc. and the reader is assumed to be relatively
familiar with the contents of the 1541 User's Manual. For the sake of
continuity and clarity, some of the information covered in the 1541 User's
Manual is also presented here. However, the majority of the information
presented in this manual is original and is the result of intensive disassembly
and annotation of the 1541's DOS by the authors. Some information is based on
articles and notes published in a variety of publications as well as
discussions with other knowledgeable disk experts.

This manual was not prepared with the assistance of Commodore Business
Machines, Inc. Although we cannot guarantee the accuracy of all the information
presented in this manual, the material has been thoroughly researched and
tested.

There were several reasons for writing Inside Commodore DOS:

1. To correct errors and omissions in the 1541 User's Manual.
2. To help you make more effective use of your disk drive.
3. To provide complete information on diskette formatting.
4. To provide complete information on the storage of files.
5. To allow you to read and write data in non-standard ways.
6. To help you make a backup copy of your "protected" diskettes.
7. To help you recover damaged diskettes.
8. To help you understand the operation of your disk drive.

Although this manual focuses primarily on the 1541 disk drive, much of the
information also applies to other Commodore disk drives.

1.1 A Brief Word About the Programs

This book contains listings for 46 ready-to-use programs written in BASIC.
These programs are copyrighted. They may NOT be used commercially, in whole
or in part, period. Since many of the programs are long, typing them all in
would be a time consuming, tedious task. Feel free to share your typing efforts
with a friend who has also purchased a copy of this book. In return, we simply
ask that you do not share a program with someone who does not own a
legitimate copy of this book.

The programs in this book are disk utilities. They do not use flashy graphics
or sound. Rather, they are extremely powerful tools. Remember, any tool can be
dangerous if it is used improperly. Be sure that you know what you are doing
before you use a given program. Always experiment with a program on a test
diskette before you actually use it on one that contains valuable programs or
data. Practice makes perfect.

Each program was individually tested on a variety of 1541 disk drives having a
wide range of serial numbers. Moreover, each program always worked perfectly.
Unfortunately, it is impossible to guarantee that a particular program will
work with your model. If a given program does not seem to work properly, check
your typing carefully. Any errors, especially in the DATA statements which
contain a machine language program, will produce problems.

As a courtesy to the more advanced programmer, we have also included the source
listings for each machine language routine A source listing immediately follows
a related BASIC program listing and has a file name ending in ".PAL". It is for
use with the PAL assembler. Note: If you are using a different assembler, you
may have to make some minor changes.

The programs in this book were designed to be not only useful and beneficial,
but instructive as well. Many of them illustrate the "state of the art" in
the use of Commodore's direct-access disk commands. Enjoy!

1.2 How to Type in the Programs

Program listings in books and magazines often suffer from two problems:
typographical errors that occur when the program is retyped into a word
processor and the readability of Commodore's control characters (e.g., the
reverse field heart that means Clear Screen). To overcome these problems, the
program listings for this book were created using a special "lister" program.
This lister program took a working BASIC program and converted it into a
WordPro™ file. At the same time, control characters were spelled out in words
and surrounded by curly brackets. For example, a reverse field heart was
converted to {CLR}. The table below summarizes the listing conventions, the
corresponding control characters, and the proper key/keys to press on your
C64 or VIC-20.

When You See            What It Represents      What You Type
----------------        --------------------    --------------
{CLR}                   Clear Screen            Hold down SHIFT and press
                                                CLR/HOME
{HOME}                  Home Cursor             Press CLR/HOME
{DOWN}                  Cursor Down             Press CRSR/DOWN
{UP}                    Cursor Up               Hold down SHIFT and press
                                                CRSR/UP
{RIGHT}                 Cursor Right            Press CRSR/RIGHT
{LEFT}                  Cursor Left             Hold down SHIFT and press
                                                CRSR/LEFT
{RVS}                   Reverse Field ON        Hold down CTRL and press 9
{ROFF}                  Reverse Field OFF       Hold down CTRL and press 0

NOTE 1: When a number appears inside the curly brackets, it means you repeat
the control character immediately to the left of the number that many times.
For example:

{DOWN 5} means to press CRSR/DOWN five (5) times.

NOTE 2: All programs have been listed in a column 40 characters wide. Except
where special characters have been spelled out between curly brackets, the
lines are listed exactly as they appear on a Commodore 64 display. Spaces must
be typed in as listed. Where necessary, count the character columns to
determine the appropriate number of spaces.

Happy hunting and pecking!
﻿
﻿
                                CHAPTER 2

                          USING THE 1541'S DOS

2.1 The Purpose of a DOS

A disk operating system (DOS) is a machine language program that controls a
disk drive. It does several different tasks:

1. Handling communications between a disk drive and a computer.
2. Carrying out housekeeping chores such as formatting a diskette.
3. Managing the storage of information on a diskette.
4. Reading and writing information onto a diskette's surface.

In many computer systems, a DOS is loaded into the main computer's memory from
diskette when the computer is first switched on. In this type of system many of
the tasks are carried out using the computer's microprocessor and RAM.
Commodore uses a different approach. All of Commodore's disk drives are
intelligent peripherals. They do not have to use the computer's resources; they
have their own. For example, the 1541 disk drive contains its own 6502
microprocessor, 2K of RAM, two 6522 I/O chips, and a DOS program permanently
stored in 15.8K of ROM.

The advantages of having an intelligent disk drive are:

1. The DOS does not use any of the computer's memory.
2. Some disk operations can be carried out independently from the CPU.
3. Disk operations do not slow down processing.
4. One disk drive can be shared among several computers.

The disadvantages of having an intelligent disk drive are:

1. It is very difficult to customize DOS routines.
2. You must replace the ROMs to convert to a new version of DOS.


2.2 Communicating with the 1541

Your Commodore 64 or VIC-20 can communicate with your 1541 disk drive in
several ways:

1. Through the LOAD, SAVE, and VERIFY commands.
2. Through I/O using the command channel.
3. Through I/O using data communication channels.

Let's examine each of these in greater detail.

1. LOAD, SAVE, and VERIFY commands:

These BASIC commands are used to store and retrieve programs on the Commodore
tape and disk drives. They are designed for ease of use, even by the novice.
The BASIC interpreter in the computer interprets these commands and sends the
disk drive the necessary information over the serial bus.

2. I/O using the command channel:

The command channel is used to send messages to the disk drive to carry out
disk operations like: formatting a blank diskette, erasing an unwanted file,
renaming a file, etc. These operations are often referred to as disk
housekeeping. The command channel is also used to input messages, such as the
current error status of the drive, generated by the DOS. For more details on
how to use the command channel, see Section 2.4.

3. I/O using data communication channels:

The 1541 DOS supports a variety of kinds of files: program files, sequential
files, relative files, user files, and direct-access files. The storage and
retrieval of information in files is carried out using a data communication
channel. Although this manual provides detailed information regarding how files
are stored and organized, no attempt is made to teach you how to develop
programs that make extensive use of file handling. We would encourage readers
who are interested in file handling techniques to refer to Jim Butterfield's
series of articles in COMPUTE!. The only I/O applications discussed in this
manual are those relating to direct-access programming (see Chapter 5).

Since the rest of this manual makes extensive use of the command channel, let's
examine it in some detail.

2.3 The Command Channel

The command channel (channel number 15) is an important communication link
between your computer and the 1541 disk drive. It has several important
functions. You can use it to:

1. Monitor the error status of the drive to ensure that everything is operating
properly.
2. Send commands that direct the DOS to perform various housekeeping chores
associated with disk handling.
3. Send commands that direct the DOS to read or write information to specific
areas on a diskette.

This chapter focuses on the first two of these uses. Chapter 5 provides more
detail on reading or writing to a diskette.

2.4 Using the Command Channel

Using the command channel is easy. Just follow these steps:

1. Establish communications using an OPEN statement.
2. Send commands to the DOS using a PRINT# statement.
3. Read DOS messages using a GET# or INPUT# statement.
4. Close the channel using a CLOSE statement when you are finished.

Let's go over each step to ensure that you know exactly what to do.

1. Establishing communications using an OPEN statement.

In order to establish a communication channel between your computer and your
1541 disk drive, you use an OPEN statement. An OPEN statement is a BASIC
command which looks like this:

SYNTAX:         OPEN file#, device#, channel#
EXAMPLE:        OPEN 15, 8, 15

where

file#           = the logical file number (1-127)
device#         = the device number (8 for a stock 1541)
channel#        = the channel number or secondary address (2-15)

NOTE:   Channel numbers 0 & 1 are reserved for use by the DOS.
        Channel numbers 2-14 are data communications channels.
        Channel number 15 is the command channel.

The OPEN statement can be used either in immediate mode (typed and executed
directly from the keyboard) or under program control (embedded in a program).

In the example above (OPEN 15, 8, 15) we opened logical file number 15 on the
C64 to device number 8 (the disk drive) through channel 15 (the command
channel).

2. Sending commands to the DOS using a PRINT* statement.

In order to send commands from your computer to the 1541, you use a PRINT#
statement. A PRINT# statement is a BASIC command which looks like this:

SYNTAX:         PRINT# file#, "command"
EXAMPLE:        PRINT#15, "N0:MY DISKETTE,MD"

where

file#   = the logical file number you used when you opened the command channel
command = the disk command to be sent to the DOS

NOTE: The statement is PRINT# not PRINT #. You must not put a space before the
# sign. Spaces following the # sign are always optional. DO NOT use ?# as an
abbreviation either. The correct abbreviation is pR (p then SHIFTED R).

In this example, the disk command is "N0:MY DISKETTE,MD". This command causes
the DOS to prepare the blank diskette in the drive for first-time use.

Although there are many different disk commands, they fall into two groups:

1. Commands related to disk housekeeping.
2. Commands to read or write data to a diskette or the disk drive's RAM.

The disk housekeeping commands are discussed in the next part of this chapter.
The commands relating to reading or writing data are discussed in Chapter 5 on
Direct-Access Programming.

3. Reading DOS messages using a GET# or an INPUT# statement.

You may use either an INPUT# or a GET# statement to read the command channel
and access any messages or data prepared for the computer by the DOS. Both
INPUT# and GET# statements are BASIC commands. They look like this:

SYNTAX:         INPUT# file#, variable list
                GET# file#, variable list

EXAMPLE:        INPUT# 15, EN, EM$, ET, ES
                GET# 15, A$

where

file#           = the logical file number you used when you opened the command
                  channel
variable list   = one or more variable names separated by commas

NOTE: As was noted for PRINT# above, the BASIC statements are INPUT# and GET#,
not INPUT # and GET #. You must not put a space before the # sign. Spaces
following the # sign are always optional. Neither the INPUT# statement nor the
GET# statement can be used in immediate mode (typed and executed directly from
the keyboard). They must be included within a program.

The INPUT# command and the GET# command operate in much the same way as the
more familiar INPUT and GET commands. INPUT# always reads as far as the next
carriage return character while GET# reads a single byte of information.
Generally, GET# is used in direct-access programming and INPUT# is used only
for monitoring the drive's error status as indicated immediately below.

You can check the error status of your disk drive using the command channel.
The DOS monitors every disk operation as it is carried out and prepares a
status report indicating whether or not the operation was completed
successfully. The report consists of an error code number, an English language
message, and the track and sector where the problem, if any, was encountered.
Here is a subroutine that checks the error status.

100 OPEN 15,8,15 : REM THE OPEN COMMAND CHANNEL
        .       .       .
500 INPUT#15,EN,EM$,ET,ES : REM INPUT THE ERROR STATUS
51O IF EN < 20 THEN RETURN : REM NO ERROR ENCOUNTERED
520 PRINT EN;EM$;ET;ES : REM PRINT THE ERROR STATUS ON SCREEN
530 CLOSE 15 : END : REM ABORT ON BAD STATUS

Line 100 opens the command channel. It is a good idea to open the command
channel at the beginning of your program and leave it open until the end. Line
500 inputs the status report. The error code number is stored in EN, the
message in EM$, the track in ET, and the sector in ES. Error codes less than 20
may be ignored (line 510). A complete list of the error codes and messages is
contained in the back of your 1541 User's Manual. A detailed explanation of the
nature and cause of many of these errors is provided in Chapter 7 on Disk
Protection.

4. CLOSE the command channel when you are done.

After you have finished using the command channel, it should be closed. Recall
that the OPEN command has three parameters: the logical file number, the device
number, and the channel number. The CLOSE command has only one, the logical
file number. It looks like this:

SYNTAX:         CLOSE file#
EXAMPLE:        CLOSE 15

where

file# = the logical file number you used when you opened the command channel

NOTE: Loading, running, or editing a program closes down all communication
channels automatically. The command channel is closed properly in each
instance. However, data channels are aborted rather than closed. When a data
channel is aborted, the file is NOT CLOSED properly on the disk drive. You do
not have to close the command channel after the issuance of every command. If
you forget to close it, the worst that can happen is a ?FILE OPEN ERROR when
you attempt to open it again. However, you should get into the habit of always
closing a file when you are finished using it. You won't get into trouble
leaving the command channel open, but you may lose an important data file if
you leave a data communication channel open.


2.5 Disk Housekeeping

As your collection of programs grows, you will have to do some housekeeping to
keep things in shape. Disk housekeeping chores include the following:

1. Preparing a blank diskette for first-time use.
2. Erasing the contents of a diskette currently in use.
3. Initializing a diskette.
4. Renaming a file.
5. Scratching or erasing a file.
6. Copying a file.

These operations are carried out by the DOS in response to commands sent to the
drive using the command channel as indicated above. Once a disk housekeeping
command is issued, the disk drive will carry out the task without further
intervention by the computer. This means that you could edit or even RUN a
program in RAM while the disk drive busily formats or validates a diskette.
This is not really spooling. It occurs because the 1541 is an intelligent
peripheral. The only thing that will cause your computer to wait for the disk
drive to complete its task is your attempting to perform another disk
operation. This includes closing the command channel.

Let's take a look at the disk commands used for housekeeping. NOTE: If you are
using the DOS SUPPORT program that came on your 1541TEST/DEMO, the syntax for
these disk commands is remarkably shorter. The > or @ keys are used to send a
command to the disk drive. They take the place of the PRINT* statement. In
addition, you do not have to open or close the command channel or embed the
disk command in quotation marks. The DOS SUPPORT program will do this
automatically for you. The DOS 5.1 syntax can be used only in immediate mode,
however. It cannot be used in a program or a ?SYNTAX ERROR will result.


The New Command

When a fresh diskette is taken from its storage envelope, the 1541 cannot
recognize it. The diskette must be formatted or newed prior to first-time use.
Formatting or newing a diskette is performed by the DOS. The DOS proceeds to
write concentric tracks made up of blocks/sectors to the diskette. In addition,
a directory is set up, wherein the drive records information about all the
files stored on the diskette. Chapter 3 provides a much more detailed account
of this operation. The syntax for formatting a diskette is really quite simple:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "N0:DISK NAME,ID"
                CLOSE 15

ALTERNATE:      PRINT#15, "N:DISK NAME,ID"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "N0:MY DISKETTE,MD"
                CLOSE 15

DOS 5.1:        >N0:DISK NAME,ID
                >N:DISK NAME,ID

The disk command, "N0:MY DISKETTE,MD", is sent to the drive by the PRINT#15
statement. The command has three parameters. The first parameter within quotes
is N0:. The N stands for NEW. The 0 is a holdover from the dual drive system
and indicates which drive. The 0 is optional on the 1541 and may be omitted.
The colon terminates the DOS command. The second parameter is the disk name. It
is limited to 16 characters in length. Generally these are alphanumeric
characters. In the example above, we named the diskette: MY DISKETTE. The disk
name is cosmetic and appears in the directory for reference purposes only. It
is not written anywhere else on the diskette. The disk name is followed by a
comma. The DOS looks or parses for this. After the comma are two alphanumeric
characters for the disk ID. In the above example we selected MD as our disk
identifier. The ID is written to every block or sector on the diskette. It is
impossible to alter. The DOS repeatedly looks at the ID of a sector to be sure
that you have not switched diskettes on it. Each diskette should be formatted
with a unique ID. This will prevent the DOS from inadvertently overwriting
programs on what appears to be an identical diskette.

A "full" new on a diskette takes roughly 2-3 minutes. There is a quicker way to
erase a diskette that has already been used. This is accomplished by leaving
off the disk ID. For example:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "N0:DISK NAME"
                CLOSE 15

ALTERNATE:      PRINT#15, "N:DISK NAME"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "N0:TEST DISKETTE"
                CLOSE 15

DOS 5.1:        >NO:DISK NAME
                >N:DISK NAME

Notice that no comma or ID follows the disk name. This command will work only
on a diskette that has previously been formatted. It is referred to as a
"short" new. A "short" new simply erases the first sector in the directory and
writes an empty BAM (block availability map) to tell the DOS that we have a
fresh diskette in use. NOTE: A diskette that is plagued by read or write errors
does not have to be pitched. Copy the files to another diskette first. Then do
a "full" new on the offending diskette. This will erase and reformat the entire
diskette. A "short" new rewrites only sectors 0 and 1 of track 18 and will not
eliminate any read or write errors. See Chapter 8 about how to recover from
both a "short" new and a "full" new.


The Initialize Command

Initialization has nothing to do with formatting. APPLE™ owners format a
diskette by "initializing" it. This is NOT TRUE with Commodore. Initializing a
diskette forces the DOS to read the disk ID and the contents of the BAM and
store them in the drive's internal memory. The BAM establishes where the next
available sector is for writing. Without it files would be overwritten. To
initialize a diskette perform the following:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "I0"
                CLOSE 15

ALTERNATE:      PRINT#15, "I"

DOS 5.1:        >I0
                >I

The I is short for INITIALIZE. The drive number can be ignored if you are using
only one 1541. The drive motor purrs for a few seconds and then settles down.
It's that simple. It is a good habit to initialize a diskette each time you
insert it into your 1541 drive. This point cannot be overemphasized. Do it
yourself. Do not rely upon the "autoinit" feature of the drive. Initialization
prevents the DOS from overwriting files in the event that two diskettes with
identical IDs are swapped. The drive cannot tell the difference between two
diskettes with identical IDs since it is the ID that the DOS uses to identify a
diskette. Initialization also assures you that a diskette is properly seated in
the drive before use.

The 1541 drive has a built in autoinitialization feature. Once it encounters an
error it will retry a disk operation several times. Often it can recover from
an error on its own. If it fails, it gives up. Before doing so, though, it will
do a "bump." On a bump the read/write head is stepped outwards 45 tracks
(slight overkill) to assure that it is on track 1. The drive clatters when a
protrusion on the stepper motor's drive pulley bumps up against a mechanical
stop. (It really isn't a melt down.) The head then steps inwards to track 18
and the DOS awaits further instructions. Self initialization avoids this
scenario. Initialize every time you insert a diskette into the drive.

Initialization clears the error channel and turns off the flashing red LED.
Unless, of course, you are trying to initialize an unformatted diskette or
forgot to put one in the drive to begin with. Clearing the error channel
destroys the error status the DOS prepared for you. If error checking is
important, retrieve the error message first; then initialize the drive.


The Rename Command

Occasionally you will want to change the name of a file stored on a diskette.
To rename a file you first open the command channel and then send the rename
command like this:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "R0:NEW NAME=OLD NAME"
                CLOSE 15

ALTERNATE:      PRINT#15, "R:NEW NAME=OLD NAME"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "R0:DISPLAY T&S=DTS"
                CLOSE 15

DOS 5.1:        >R0:NEW NAME=OLD NAME
                >R:NEW NAME=OLD NAME

Again the syntax is exacting but simple to follow. The R0: means to rename on
drive 0. It is short for RENAME0:. As before, the 0 is optional on the 1541.
The next parameter is the new file name. A file name is generally alphanumeric
in nature and 16 characters are allowed at the maximum. (Commas, colons,
semicolons, and wild cards are not permitted. Cursor control and reverse video
characters should be avoided.) The new file name is followed by an " = " sign.
The last parameter is the existing or old file name. It must be spelled out
exactly as it appears in the directory. Wild cards (*,?) are not allowed. If
you make a typo on this parameter or the file does not appear in the directory,
the rename command fails. No damage is done, so relax. In the above example our
new file name is DISPLAY T&S. It replaces the old file name DTS. One final
point. You cannot rename a file that is currently open for a read or write.


The Copy Command

The copy command allows you to easily backup an existing file on your diskette.
There are three restrictions attached. First, the new file must have a
different name. Second, the copy command will not work on a relative file.
Third, you must have enough room on the diskette. The copy command looks like
this:

SYNTAX:
        OPEN 15, 8, 15
        PRINT#15, "C0:BACKUP=0:ORIGINAL"
        CLOSE 15

ALTERNATE:
        PRINT#15, "C:BACKUP=ORIGINAL"

EXAMPLE:
        OPEN 15, 8, 15
        PRINT#15, "C0:MY PROGRAM B/U=0:MY PROGRAM"
        CLOSE 15

DOS 5.l:
        >C0:BACKUP=0:ORIGINAL
        >C:BACKUP=ORIGINAL

The C is short for COPY. The new file above is called MY PROGRAM B/U. It is a
backup copy of a previous program called MY PROGRAM. Note that we must specify
the drive number twice. Again this is a holdover from a dual drive
configuration. The C does not appear twice, however. The same restrictions that
apply to the rename command are also in effect here, i.e., 16 character file
name limit, use of restricted characters, etc. The drive number is optional.
See the alternate syntax to save a few keystrokes.

It is also possible to merge two or more sequential data files using the copy
command. The syntax for this is as follows:

SYNTAX:
        OPEN 15, 8, 15
        PRINT#15, "C0:COMBINED=0:FILE1,0:FILE2,0:FILE3"
        CLOSE 15

ALTERNATE:
        PRINT#15, "C:COMBINED=FILE1,FILE2,FILE3"

EXAMPLE:
        OPEN 15, 8, 15
        PRINT#15, "C0:MAILFILE=0:NAME,O:ADDRESS,0:CITY"
        CLOSE 15

DOS 5.l:
        > CO:COMBINED=0:FILE1,0:FILE2,0:FILE3
        >C:COMBINED=FILE1,FILE2,FILE3

Our large file now consists of several files appended together. While this
feature of the copy command is available, it is rarely used. Few programming
techniques would require or ever utilize this feature. Note that this technique
cannot be used to append a subroutine onto a BASIC program; the subroutine
cannot be merged into the main program by the disk drive. You will need to use
a programmer's aid like POWER™, SYSRES™, or BASIC AID™ for the C64 to do this.


The Scratch Command

To get rid of an unwanted file, we scratch it. The only exception is an
unclosed file. An unclosed file is one that appears in the directory as having
zero blocks and whose file type is preceded by an asterisk (*SEQ, *PRG, etc.).
This will be explained below. To scratch a file, first remove the write protect
tab and key in:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "S0:FILE NAME"
                CLOSE 15

ALTERNATE:      PRINT#15, "S:FILE NAME"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:TESTING 123"
                CLOSE 15

DOS 5.1:        >SO:FILE NAME
                >S:FILE NAME

The scratch command requires a single parameter, the file name, preceded by S
or SCRATCH. As before, the drive number is optional.

There are some variations that incorporate wild cards. Wild cards in a file
name are asterisks (*) or question marks (?). They should be used with utmost
caution since more than one file can be scratched at a time.

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:T*"
                CLOSE 15

DOS 5.1:        >S0:T*

In the above example all files beginning with the letter T, regardless of file
type, will be scratched. In the event that no file starts with the letter T,
none will be affected. Careless use of a wild card can have catastrophic
results. For example:

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:*"
                CLOSE 15

DOS 5.1:        >S0:*

The above command will scratch every file on the diskette. It is the equivalent
of performing a short new on a diskette. Be careful!

The second wild card is the question mark. It is used to mask out characters
that are not of importance. Suppose we want to scratch a number of files whose
names are all eight characters long and end in .C64. We could not use .C64* to
scratch them since the match falls at the end of the file name. However, we
could use:

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:????.C64"
                CLOSE 15

DOS 5.1:        >S0:????.C64

Note that we used four question marks in the above example. An exact match of
.C64 must occur on characters 5 through 8 of the file name. No match — no
scratch. If we had 1541.C64 and C100.C64 on the disk, both would be scratched
by the previous command. However, BACKUP.C64 would not be affected.

More than one wild card can be used within the same command. For example:

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:T?ST*"
                CLOSE 15

DOS 5.1:        >S0:T?ST*

This command would scratch files with these names: TEST, TASTY, TESTING123. The
file TOAST would not be affected. Note that it makes no sense to send a command
like this: "S0:T*ST???". The asterisk has priority over the question mark. All
characters that appear after the asterisk are ignored.

A file type that begins with a * is unclosed: *SEQ, *PRG, etc. It was never
closed properly. This can happen for a variety of reasons:

1. The diskette may have been at its physical capacity and a disk-full
   situation occurred during a save or write to a diskette.

2. A bad sector may have been encountered during a write to a diskette.

3. The file may have been left open following a write operation because you
   forgot to CLOSE the file, or you aborted the program by hitting either the
   RUN/STOP key or the RUN/STOP and the RESTORE keys.

4. Your program had a syntax error in it and the BASIC interpreter returned you
   to immediate mode.

(See Chapter 8 about how to recover an unclosed file.)

Whatever the cause, an unclosed file should never be scratched! Since the write
operation was aborted, the internal organization of the diskette (i.e., the
BAM), has been left in disarray. It does not match the actual file contents of
the diskette. Any further attempt to write to that diskette will probably cause
a loss of one or more files. Files can actually overlap one another now and you
will be left with a poisoned diskette. The DOS does have a command to decorrupt
itself. This is the validate command. When in doubt, validate your diskette!

The scratch command does not actually erase the file on your diskette. Rather
it traces the file across the surface of the diskette and frees any sectors the
file occupied. The file-type byte is also changed to a zero in the directory
which indicates to the DOS that it is no longer active. If you inadvertently
scratch a file that you didn't mean to, stop right then and there! You can
recover it. Do not attempt to write to the diskette. The sectors just freed
will be used on subsequent writes to the diskette. Once you write to the
diskette, recovery is impossible. Chapter 8 on Getting Out of Trouble shows you
how to recover a scratched file.


The Validate Command

This command tells the DOS to reconstruct its map which shows where information
is stored on the diskette, so it conforms to the files listed in the directory.
This is a simple way to decorrupt a damaged diskette. However, it is not a
failsafe command as will be explained shortly. A validate command looks like
this:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "V0"
                CLOSE 15

ALTERNATE:      PRINT#15, "V"

DOS 5.1:        >V0
                >V

The V is an abbreviation for VALIDATE. As before, the 0 is optional for the
1541 drive.

What does a validate do? The DOS keeps a map that indicates which sectors on a
diskette are currently in use. This map is stored on track 18, sector 0. It is
referred to as the Block Availability Map or just the BAM for short. When the
validate command is issued, all blocks are freed in the BAM on the diskette
simulating a newly formatted blank diskette. The drive then picks up the first
file in the directory and chains through the entire file. As sectors are picked
up along the way, they are allocated in the BAM as currently in use. If the
file is traced successfully, all blocks associated with it are put back into
the BAM as in use. The next file is then picked up out of the directory and the
process continues. When all files have been traced, the new BAM is written to
the diskette and the internal count now matches the directory contents.

So far so good. Now let's see what happens to an unclosed file. When the DOS
encounters an unclosed file in the directory during a validate command, all it
does is change the file type byte in the directory entry to a 0 (scratched
file). No attempt is made to trace the file. When the validate operation is
complete, the unclosed file will no longer appear in a directory listing and
any blocks associated with it will be free. This is what you want to happen.
Now let's see what happens if you attempt to SCRATCH an unclosed file.

When you scratch a file, two things happen: the file-type byte in the directory
for this file is set to 0 (scratched file) and the DOS traces through the chain
of sectors that make up the file and marks each sector it encounters as
available for use (free) in the BAM. This is just what you want to have happen
for a normal file, but it can poison the diskette when you try it on an
unclosed file. Here's why. The last sector of an unclosed file was never
written out to the diskette. As a result, the second to the last sector points
to a sector that is not really part of the file. The DOS doesn't realize this
and continues to follow the "chain." If you are lucky, the "unwritten sector"
will be a empty sector (never used since the disk was formatted). If this
happens, the DOS will stop because pointers point to a non-existent track and
sector (75,1). If you are unlucky, the "unwritten sector" will be part of a
file that you scratched last week and the pointer will just happen to point
into the middle of that very important file you just saved yesterday. When this
happens, the DOS will merrily deallocate the remaining sectors in your file.
The next write operation to the diskette will see this nice big open space and
the new information will be saved right on top of your active file. Now the
situation has gone from bad to worse and is in fact pathological — hence a
poisoned disk. The only solution is to inspect each file first to ensure that
it is not tainted and then copy it onto another diskette.

The validate routine is aborted if an error (an unreadable sector) is
encountered. When it aborts, nothing radical occurs. The new BAM is not written
to the disk until the validation process has been completed. Don't worry about
the blank BAM getting you in trouble; the DOS will read the old one back in
before it allows you to write to the disk. However, the diskette still remains
corrupted with no quick remedy in sight. Chapter 8 on recovery deals with this
and other disasters.

﻿
﻿
CHAPTER 3

DISKETTE FORMATTING

When you take a new floppy diskette out of the package, it is blank. Before the
drive can store data onto it, it must be formatted. This is done by inserting
the diskette into the drive and sending a NEW command to the DOS (see Section
2.5). During "formatting" or "newing", 35 concentric tracks are written to the
diskette. Each track is made up of varying numbers of sectors/blocks where
programs and data will eventually be stored. In addition to laying down empty
blocks/sectors, the DOS creates a directory and a block availability map (BAM)
and records them on track 18.

This chapter describes the formatting process and the tracks and sectors of a
diskette. Chapter 4 describes the directory and the block availability map
(BAM).

3.1 Layout of Tracks and Sectors

During the formatting (newing) process, the DOS divides the diskette into
tracks and sectors. A track is a circular path on the diskette along which
information is stored.

Each track is concentric with the hole in the center of the diskette. There are
a total of 35 tracks numbered from 1 to 35. Track 1 is the outermost track and
track 35 is the innermost track. The read/write head may be positioned to any
given track. The position of track 1 is determined by a mechanical stop that
limits the outward movement of the read/write head. The other tracks are
identified by their distance from track 1. The diagram below indicates the
layout of the tracks on a formatted diskette.

[tracks layout diagram - omitted]

[sectors layout diagram - omitted]

Although there are only 35 tracks, the stepper motor can position the
read/write head to more than 70 different positions. This might seem to imply
that additional tracks could be recorded on the surface of the diskette to
increase its storage capacity. Unfortunately, the accuracy of the head
positioning mechanism and the width of the path of magnetization produced by
the read/write head makes the use of these "phantom" tracks unreliable. If you
would like to experiment with this, the programs described in Chapter 9 allow
you to experiment with stepping the head around.

Each track is divided into seventeen or more sectors (blocks). Each sector
holds 256 bytes of data. (Some manufacturers record data in 512 or 1024 byte
sectors.) Whenever data is read from or written to a diskette, it is done one
complete sector at a time.

On Commodore disk drives, the tracks are not divided into a fixed number of
sectors. The number of sectors depends on the track number. The outer tracks
(lower numbers) are longer and are divided into more sectors than the inner
(higher numbered) tracks. The table below summarizes how the diskette is
organized.

Organization of Tracks and Sectors on a 1541 Formatted Diskette

            Track      Range of Sector     Total Sectors   Total Bytes
   Zone    Numbers        Numbers            Per Track      Per Track
   ----    --------    ---------------     -------------   -----------
     1      1 to 17       0 to 20               21            5376
     2     18 to 24       0 to 18               19            4864
     3     25 to 30       0 to 17               18            4608
     4     31 to 35       0 to 16               17            4352

A total of 683 sectors are written at the time of initial formatting. Since the
disk rotates at a constant speed of 300 rpm, you may wonder how Commodore
manages to vary the number of sectors from zone to zone. This is accomplished
by varying the rate at which data is read or written (changing the clock rate).
Each of the four zones uses a different clock rate. This is accomplished by
using a high speed clock and dividing the clock by N, where the value of N is
determined by the zone. The table below summarizes the clock rates for each
zone.

   Zone    Tracks    Divisor      Clock Rate      Bits/Rotation
   ----   --------   -------   ----------------   -------------
    1      1 to 17     13      307,692 bits/sec     61,538.4
    2     18 to 24     14      285,714 bits/sec     57,142.8
    3     25 to 30     15      266,667 bits/sec     53,333.4
    4     31 to 35     16      250,000 bits/sec     50,000.0

This scheme provides a recording density that varies from about 4000 bits/inch
on the outer tracks to almost 6000 bits/inch on the inner tracks.

If all of the possible bits could be used for data alone, we would be able to
store a total of 2,027,676 bits or 253,459 bytes on a diskette. Unfortunately,
not all of these bytes can be used for data. The total storage capacity of a
diskette formatted on the 1541 is 174,848 bytes. The need for space to store a
directory to keep track of the location of the files on a diskette (see Chapter
4) further reduces us to an effective storage capacity of 169,984 bytes (256
bytes * 664 sectors).

3.2 Layout of a Sector

During the formatting (newing) process, the DOS creates and records onto the
diskette all 683 sectors/blocks that will eventually be used for storing
information. Each sector is comprised of two parts:

1. A header block that identifies the sector.
2. A data block that holds the 256 bytes of data.

The diagram below illustrates how these parts are arranged.

      SECTOR #0                             SECTOR #1
---------------------------------------------------------------------------
| |              | |              |#| | |              | |                |
| | HEADER BLOCK | |   DATA BLOCK |#| | | HEADER BLOCK | |   DATA BLOCK   | --+
| |              | |              |#| | |              | |                |   |
---------------------------------------------------------------------------   |
                                                                              |
                             +------------------------------------------------+
                             |
                             |             SECTOR #2   |\
                             |    ---------------------- \
                             |    |#| | |                 \
                             +--> |#| | | HEADER BLOCK     >
                                  |#| | |                 /
                                  ---------------------| /
                                                       |/
                 ---              ---
                 | |              |#|
                 | | = sync mark  |#| = inter-sec gap
                 | |              |#|
                 ---              ---

The sectors are recorded in numerical sequence along the circular track. Each
sector consists of an identifying header block followed by a data block. The
sectors are separated from each other by an inter-record gap. A special
character called a SYNC MARK is used to mark the beginning of each header or
data block.

A SYNC MARK is a very special character. It consists of 10 or more 1 bits in a
row (normally 40 of them). This particular pattern of bits only occurs at the
start of a header or data block. The hardware in the 1541 drive can detect this
character and signal the DOS that a new data or header block is coming.

If you are puzzled about why several $FF characters in a row in the data block
are not interpreted as a sync character, you may want to skip ahead to the
section on Commodore's GCR encoding scheme in Chapter 7.

3.3 The Header Block

The header block of a sector allows the DOS to identify which track and sector
is being read. It is composed of a sync mark, eight bytes of identifying
information, and a header gap. The diagram below shows the layout of a header
block.

------------------------------------------------------------------
| SYNC |  HEADER  | HEADER BLOCK | SECTOR | TRACK  | ID CHARACTER \
| MARK | BLOCK ID |   CHECKSUM   | NUMBER | NUMBER |   NUMBER 2   / ---+
------------------------------------------------------------------\    |
                                                                       |
  +--------------------------------------------------------------------+
  |
  |    -----------------------------------------------
  +--> \ ID CHARACTER | $0F BYTE | $0F BYTE | HEADER |
       /   NUMBER 1   |          |          |  GAP   |
       \----------------------------------------------

NOTE: The header is recorded on disk exactly as indicated above. The diagram on
page 54 of the 1541 User's Manual is incorrect.

Let's examine the bytes that make up the header block:

Sync Mark: This consists of 10 or more 1 bits as described above. It warns the
DOS that either a data block or a header block is coming.

Header Block ID: This is normally a $08 byte. It serves to indicate to the DOS
that this is a header block and not a data block.

Header Block Checksum: This is a checksum character used by the DOS to ensure
that the header block was read correctly. It is found by EORing the track
number, the sector number, and the two ID characters. If you are not sure what
an EOR is, you may want to read through Section 7.1.

Sector Number: This byte is the number of this particular sector. The sectors
are numbered consecutively around a track.

Track Number: This byte is the number of this particular track. The DOS uses
this byte to check to be sure that the record/play head is positioned to the
correct track.

ID Character #2: This is the second ID character that you specified in the NEW
command when the diskette was formatted (e.g., the 1 in "N0:GAMES,V1"). It is
sometimes referred to as the ID HI. The DOS checks this byte against a master
disk ID to ensure that you have not swapped diskettes.

ID Character #1: This is the first ID character that you specified in the NEW
command when the diskette was formatted (e.g., the V in "N0:GAMES,V1"). It is
sometimes referred to as the ID LO. The DOS checks this byte against a master
disk ID to ensure that you have not swapped diskettes.

$0F Bytes: These bytes are used as padding (spacing) by the DOS during initial
formatting. They are called "OFF" bytes. Once formatting is complete OFF bytes
are never referenced again.

Header Gap: The header gap consists of eight $55 bytes. These eight bytes are
used to provide breathing room between the header block and the data block. The
DOS never reads these bytes. They allow the DOS time to set-up for reading the
data block that follows. NOTE: The 4040 drive uses a nine byte header gap. This
is one of the reasons why 1541 drives and 4040 drives are NOT WRITE COMPATIBLE!
See Chapter 9 for more information.

NOTE: A header block is written only during the formatting process. It is never
rewritten again, period.

3.4 The Data Block

The data block of a sector stores the 256 data bytes for this sector. It is
composed of a sync mark, a data block ID character, the 256 bytes of data, a
data block checksum byte, two off bytes, and an inter-sector gap. The diagram
below depicts the layout of a data block.

-------------------------------------------------------------------
| SYNC | DATA  |      256       | DATA     | $00  | $00  | INTER- |
| MARK | BLOCK |   DATA BYTES   | BLOCK    | BYTE | BYTE | SECTOR | --+
|      | ID    |                | CHECKSUM |      |      | GAP    |   |
-------------------------------------------------------------------   |
                                                                      |
                           +------------------------------------------+
                           |
                           |                           |\
                           |    ------------------------ \
                           |    |  SYNC |  HEADER |       \
                           +--> |  MARK |  BLOCK  |        >
                                |       |  ID     |       /
                                ------------------------ /
                                                       |/

Let's examine the bytes that make up the data block:

Sync mark: This consists of 10 or more 1 bits as previously described. It warns
the DOS that either a data block or a header block is coming.

Data Block ID: This byte is normally a $07. It serves to indicate to the DOS
that this is a data block and not a header block ($08).

256 Data Bytes: This is the actual data stored in the sector. See Chapter 4
about how Commodore uses the first two bytes as a forward track and sector
pointer instead of actual data.

Data Block Checksum: This is a checksum character used by the DOS to ensure
that the data block was read correctly. It is found by EORing all 256 data
bytes together.

$00 Bytes: These two bytes are also called OFF bytes. They are used to pad a
data block before it is written. They are not referenced again by the DOS.

Inter-sector Gap: This is also known as the "tail gap." Its purpose is to
provide breathing room between the end of the data block and the start of the
next sector. The length of the gap varies from zone to zone and from one drive
to another (see the chart in Section 7.1). Between consecutive sectors the gap
is normally 4 to 12 bytes long. The gap between the last sector on a track and
sector zero is often longer — up to 100 bytes in length. The gap is designed to
be long enough so that if you write a data block on a day when your drive is
turning slightly faster than 300 rpm, you won't overwrite the start of the next
sector. (Your drive may not be turning at exactly 300 rpm all the time because
of fluctuations in the power supplied to your home or office, mechanical wear,
belt slippage, changes in temperature, etc.) Note that the DOS never reads
these bytes.

The entire data block (including the preceding sync mark) is rewritten each
time data is recorded on a diskette.

This concludes our overview on how a diskette is formatted. Additional details
about how bytes are encoded on the surface of a diskette are provided in
Section 7.1. The actual recording process is described in Section 9.7.

﻿

CHAPTER 4

DISKETTE ORGANIZATION

4.1 Information Management

The information that is stored on a floppy disk is virtually useless unless it
can be retrieved quickly. As a result, the organization and management of
information is one of the most important tasks of the DOS. To do an efficient
job of management, the DOS must be able to:

1. Keep track of which sectors contain data and which are still empty
(available for use).

2. Assign names and storage locations to large blocks of related information
(files).

3. Keep track of the sequence of sectors that were used to store a file.

The DOS stores most of this information in the directory on track 18, halfway
between the outermost track (1) and the innermost track (35). Centering the
directory serves to minimize head movement across the diskette and extends the
life of both the drive and the media. The directory is subdivided into two
areas—the map showing which sectors are in use and which are free (the Block
Availability Map or BAM) and directory entries. The BAM resides solely on
sector 0 of track 18. It informs the drive as to what sectors are currently in
use and where subsequent writing to the diskette can safely take place. The
remaining sectors (1-18) of track 18 contain directory entries (file names,
file types, and pointers to where files are stored on the diskette).

4.2 The Directory You See

Let's examine the directory of the 1541TEST/DEMO diskette that came with your
drive. Insert it in your drive and type on your keyboard:

LOAD "$0",8

then type

LIST

After a brief pause you should see the following on your screen:

0 "1541TEST/DEMO   " ZX 2A
13   "HOW TO USE"       PRG
5    "HOW PART TWO"     PRG
4    "VIC-20 WEDGE"     PRG
1    "C-64 WEDGE"       PRG
4    "DOS 5.1"          PRG
11   "COPY/ALL"         PRG
9    "PRINTER TEST"     PRG
4    "DISK ADDR CHANGE" PRG
4    "DIR"              PRG
6    "VIEW BAM"         PRG
4    "CHECK DISK"       PRG
14   "DISPLAY T&S"      PRG
9    "PERFORMANCE TEST" PRG
5    "SEQUENTIAL FILE"  PRG
13   "RANDOM FILE"      PRG
558 BLOCKS FREE.

The 0 refers to which drive was accessed. This is a holdover from the 4040 dual
drive system. Next you see the diskette name — 1541TEST/DEMO. In the event that
the diskette name is less than 16 characters in length, blank spaces are
appended to the end of the name. This forced spacing is known as padding.
Following the name of the diskette is the disk ID — ZX in this instance. These
two characters are generally (but not always) the unique alphanumeric
characters under which the diskette in question was formatted originally. The
diskette name and ID are cosmetic in nature and appear in the directory for
your reference purposes only. The 2A indicates the DOS version and format, 4040
in this instance — again a holdover. Next we see the active file entries on the
diskette itself. Each directory entry has three fields:

1. The number of blocks/sectors the given file occupies.
2. The file name.
3. The file type.

Your demo diskette came with 15 active files on it. Moreover, they are all
program files denoted by PRG. The last entry in the directory is the remaining
number of available blocks/sectors left on the diskette for storage. It is the
difference between 664 blocks available at the time of original formatting and
the sum of the blocks of the active files (664 - 106 = 558).

What you see on your screen is not necessarily how the directory is stored on
your diskette, however. Let's begin our look at the directory with the Block
Availability Map (BAM).

4.3 The Block Availability Map (BAM)

The BAM is where the DOS keeps track of which sectors (blocks) on the diskette
contain information (are in use) and which ones can be used for storing new
information (are free). This map is stored on track 18, sector 0. Here is a hex
dump of that sector on the 1541TEST/DEMO disk so we can examine it in detail.

            1541TEST/DEMO

         TRACK 18 - SECTOR 0

. 00: 12 01 41 00 15 FF FF 1F ..A.....  BAM TRACK   1
. 08: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  2-3
. 10: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  4-5
. 18: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  6-7
. 20: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  8-9
. 28: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS 10-11
. 30: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS 12-13
. 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
. 40: 00 00 00 00 00 00 00 00 ........  BAM TRACKS 16-17
. 48: 10 EC FF 07 00 00 00 00 ........  BAM TRACKS 18-19
. 50: 00 00 00 00 12 BF FF 07 .....?..  BAM TRACKS 20-21
. 58: 13 FF FF 07 13 FF FF 07 ........  BAM TRACKS 22-23
. 60: 13 FF FF 07 12 FF FF 03 ........  BAM TRACKS 24-25
. 68: 12 FF FF 03 12 FF FF 03 ........  BAM TRACKS 26-27
. 70: 12 FF FF 03 12 FF FF 03 ........  BAM TRACKS 28-29
. 78: 12 FF FF 03 11 FF FF 01 ........  BAM TRACKS 30-31
. 80: 11 FF FF 01 11 FF FF 01 ........  BAM TRACKS 32-33
. 88: 11 FF FF 01 11 FF FF 01 ........  BAM TRACKS 34-35
. 90: 31 35 34 31 54 45 53 54 1541TEST  DISK NAME
. 98: 2F 44 45 4D 4F A0 A0 A0 /DEMO
. A0: A0 A0 5A 58 A0 32 41 A0   ZX 2A   DOS TYPE & DISK ID
. A8: A0 A0 A0 00 00 00 00 00    .....  UNUSED
. B0: 00 00 00 00 00 00 00 00 ........
. B8: 00 00 00 00 00 00 00 00 ........
. C0: 00 00 00 00 00 00 00 00 ........
. C8: 00 00 00 00 00 00 00 00 ........
. D0: 00 00 00 00 00 00 00 00 ........
. D8: 00 00 00 00 00 00 00 00 ........
. E0: 00 00 00 00 00 00 00 00 ........
. E8: 00 00 00 00 00 00 00 00 ........
. F0: 00 00 00 00 00 00 00 00 ........
. F8: 00 00 00 00 00 00 00 00 ........

As indicated above, the BAM does not take up all 256 bytes on this sector.
There are several other things stored here as well. The table below identifies
the various parts. Note that the sector dump above uses hexadecimal notation
while the table below gives the decimal equivalents.

Bytes           Contents        Purpose
-------         ---------       -----------------------------------------------
0/1             18/1            Pointer to first sector of directory entries
2               65              ASCII character A indicating 1541/4040 format
3               0               Unused
4-143                           Block Availability Map (BAM)
144-159                         Diskette name padded with shifted spaces
160-161         160             Shifted spaces
162-163                         Diskette ID
164             160             Shifted space
165-166         50/65           DOS version and format type (2A)
167-170         160             Shifted spaces
170-255         ?               Unused

In the BAM four bytes are used to describe the status of each track. As a
result, the BAM takes up a total of 4 x 35 = 140 bytes (bytes 4-143 or
$04-$8F). Let's examine the entry for track 14 to see what these four bytes
mean. The entry for track 14 begins at byte 14 x 4 = 56 ($38). It looks like
this:


. 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
      ** ** ** **

The first byte for track 14 (location $38 = 56) indicates the number of blocks
free on this track.


. 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
      **

In this case there are $11 or 17 (1 * 16 + 1) blocks free.

When the DOS calculates the number of blocks free on a diskette, it sums this
byte from each track's entry in the BAM. Let's do our own blocks free
calculation to see how it is done. All we have to do is sum up the decimal
values of every fourth byte starting with byte 4 like this:

                          HEX    DECIMAL
 ZONE    BYTE    TRACK   VALUE    VALUE
------  ------  ------- ------- ---------
  1        4       1      $1F       21
           8       2      $1F       21
          12       3      $1F       21
          16       4      $1F       21
          20       5      $1F       21
          24       6      $1F       21
          28       7      $1F       21
          32       8      $1F       21
          36       9      $1F       21
          40      10      $1F       21
          44      11      $1F       21
          48      12      $1F       21
          52      13      $1F       21
          56      14      $11       17
          60      15      $00        0
          64      16      $00        0
          68      17      $00        0

2         72      18      $10       16
          76      19      $13       19
          80      20      $13       19
          84      21      $13       19
          88      22      $13       19
          92      23      $13       19
          96      24      $13       19

3        100      25      $12       18
         104      26      $12       18
         108      27      $12       18
         112      28      $12       18
         116      29      $12       18
         120      30      $12       18

4        124      31      $11       17
         128      32      $11       17
         132      33      $11       17
         136      34      $11       17
         140      35      $11     + 17
                                ---------
                                   574          BLOCKS FREE

Wait a minute! We calculated 574 blocks free but the directory shows 558. How
do we explain this discrepancy? Easy. Remember that the DOS reserves track 18
for its own use. Therefore the blocks free on that particular track are not
returned to us (574 - 16 = 558). Sixteen sectors on track 18 are still free,
but available only to the DOS.

Now that you have seen how to calculate the number of blocks free on a
diskette, let's get back to our analysis of track 14. The BAM entry looked like
this:


. 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
      ** ** ** **

The first byte was easy to interpret. The remaining three bytes are a bit
trickier (no pun intended). They are a bit map showing the status of the
sectors on a given track. Bit mapping is used to save space. If one byte were
used for each of the 683 sectors, the BAM would take up three sectors (683 /
256). This would be inefficient. By using bit mapping, each byte describes the
status of eight sectors. This way only three bytes are needed for each track.
Let's examine the bit map for track 14 of our 1541 TEST/DEMO.


. 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
      ** ** ** **

 LOCATION       $39=57          $3A=58          $3B=59
BYTE VALUE       $D7             $5F             $1F
  BINARY       11010111        01011111        00011111 *

  SECTOR                       111111             21111
  NUMBER       76543210        54321098        xxx09876

             * 1 = FREE
               O = ALLOCATED

Sectors 0 to 7 are represented by the byte at location 57. Sectors 8 through 15
are stored in the byte at location 58. Finally, sectors 16 through 20 are
depicted by the byte at location 59. When decoded, a bit that is high or a 1
indicates that a sector is not currently in use (free) and can be written to. A
bit that is low or a 0 is currently in use (allocated) and will be overlooked
by the DOS when writing subsequently takes place to the diskette. The third
byte is always incomplete since a maximum of 21 sectors are written to any
track. This particular byte is automatically adjusted by the DOS during initial
formatting to indicate the proper number of sectors for this track. Three bytes
are still used irregardless of the zone, however. If you count up the 1s in the
bit map for track 14, you will find that there are 17 free sectors on track 14.
This agrees with the blocks free count for the track stored at byte location
$38 (56) in the BAM, i.e., $11 or 17 decimal.

To ensure that you understand how the bit mapping works, let's take a look at
track 18. Since track 18 is used for storing the directory we would expect some
allocation of sectors here. Byte 72 shows $10 or 16 sectors available here.
They are bit mapped in bytes 73, 74, and 75 as follows:


. 48: 10 EC FF 07 00 00 00 00 ........  BAM TRACKS 18-19
      ** ** ** **

 LOCATION       $49=73          $4A=74          $4B=75
BYTE VALUE       $EC             $FF             $07
  BINARY       11101100        11111111        00000111 *

  SECTOR                       111111             21111
  NUMBER       76543210        54321098        xxx09876

             * 1 = FREE
               O = ALLOCATED

If you are still unsure of yourself, don't be too concerned. The DOS looks
after the BAM. Let's move on and explore the actual directory entries
themselves. Sectors 1 through 18 on track 18 are reserved specifically for them.

4.4 The Directory Entries

Recall that bytes 0 and 1 of track 18, sector 0 point to the next track and
sector of the directory. In this particular instance, the BAM points to track
18, sector 1. Let's examine this sector in detail.

            1541TEST/DEMO

         TRACK 18 - SECTOR 01

. 00: 12 04 82 11 00 48 4F 57 .....HOW  FILE ENTRY #1
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 0D 00 ........
. 20: 00 00 82 11 03 48 4F 57 .....HOW  FILE ENTRY #2
. 28: 20 50 41 52 54 20 54 57  PART TW
. 30: 4F A0 A0 A0 A0 00 00 00 O    ...
. 38: 00 00 00 00 00 00 05 00 ........
. 40: 00 00 82 11 09 56 49 43 .....VIC  FILE ENTRY #3
. 48: 2D 32 30 20 57 45 44 47 -20 WEDG
. 50: 45 A0 A0 A0 A0 00 00 00 E    ...
. 58: 00 00 00 00 00 00 04 00 ........
. 60: 00 00 82 13 00 46 2D 36 .....C-6  FILE ENTRY #4
. 68: 34 20 57 45 44 47 45 A0 4 WEDGE
. 70: A0 A0 A0 A0 A0 00 00 00      ...
. 78: 00 00 00 00 00 00 01 00 ........
. 80: 00 00 82 13 01 44 4F 53 .....DOS  FILE ENTRY #5
. 88: 20 35 2E 31 A0 A0 A0 A0  5.1
. 90: A0 A0 A0 A0 A0 00 00 00      ...
. 98: 00 00 00 00 00 00 04 00 ........
. A0: 00 00 82 13 03 43 4F 50 .....COP  FILE ENTRY #6
. A8: 59 2F 41 4C 4C A0 A0 A0 Y/ALL
. B0: A0 A0 A0 A0 A0 00 00 00      ...
. B8: 00 00 00 00 00 00 0B 00 ........
. C0: 00 00 82 13 09 50 52 49 .....PRI  FILE ENTRY #7
. C8: 4E 54 45 52 20 54 45 53 NTER TES
. D0: 54 A0 A0 A0 A0 00 00 00 T    ...
. D8: 00 00 00 00 00 00 09 00 ........
. E0: 00 00 82 10 00 44 49 53 .....DIS  FILE ENTRY #8
. E8: 4B 20 41 44 44 52 20 43 K ADDR C
. F0: 48 41 4E 47 45 00 00 00 HANGE...
. F8: 00 00 00 00 00 00 04 00 ........


The contents of any directory sector can be tabled as follows:

Byte            Contents        Purpose
--------        --------        -------------------------------------
     0                          Track of the next directory block
     1                          Sector of the next directory block

  2-31                          File entry #1 in the directory block

 32-33             0            Unused
 34-63                          File entry #2 in the directory block

 64-65             0            Unused
 66-95                          File entry #3 in the directory block

 96-97             0            Unused
 98-127                         File entry #4 in the directory block
128-129            0            Unused
130-159                         File entry #5 in the directory block

160-161            0            Unused
162-191                         File entry #6 in the directory block

192-193            0            Unused
194-223                         File entry #7 in the directory block

224-225            0            Unused
226-255                         File entry #8 in the directory block

Eight file entries are recorded per sector. Let's examine the contents of a
single directory file entry.

. 00: 12 04 82 11 00 48 4F 57 .....HOW
      ** **
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 0D 00 ........

Because this is the first entry in the directory, bytes 0 and 1 are
significant. They point to track 18, sector 4 (converts to 18). This indicates
that there are further directory entries. You will note that the sectors are
not sequential in nature, i.e., sector 1 does not point to sector 2, etc.
Remember that the diskette itself is rotating at 300 rpm. Staggering the use of
the sectors allows quicker access and fewer rotations of the drive mechanism
and the media. Typically sectors are staggered in increments of 10. The
directory track is staggered in increments of 3, however. The table below
indicates the sequence in which a full directory containing 144 files is stored:

        SECTOR FILLING SEQUENCE
           FOR THE DIRECTORY

             0 (BAM)
             1, 4, 7, 10, 13, 16
             2, 5, 8, 11, 14, 17
             3, 6, 9, 12, 15, 18


When a diskette is initially formatted, sector 1 is set up with 8 null entries.
As you store files on the diskette the directory grows. It soon becomes a long
chain of directory sectors. The first two bytes in a sector point to the next
directory sector in the chain (this is known as a forward pointer). But, what
about the last sector in the chain? It has nothing to point to! In the last
sector in the chain, there is no forward pointer; byte 0 contains a 0 ($00) and
byte 1 contains a 255 ($FF) as indicated below. This indicates to the DOS that
there are no more sectors in the directory.

. 00: 00 FF xx xx xx xx xx xx ........

One final note about chaining. Commodore uses only forward pointers. A sector
does not show where it came from, only where it is going. This makes recovery
of corrupted files much more difficult, but more about that later.

Back to our example:

. 00: 12 04 82 11 00 48 4F 57 .....HOW
            **
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 0D 00 ........

The first byte in the file entry is the file-type byte. In this instance we see
an $82. This is interpreted by the DOS to mean that the file entry is a
program. The following table outlines Commodores file types.

HEX      ASCII   FILE TYPE                      DIRECTORY SHOWS
-----   -------  -----------------------        ----------------

$00        0     Scratched                      Does not appear

$80      128     Deleted                        DEL
$81      129     Sequential                     SEQ
$82      130     Program                        PRG
$83      131     User                           USR
$84      132     Relative                       REL

$00        0     Unclosed deleted               Same as scratched
$01        1     Unclosed sequential            *SEQ
$02        2     Unclosed program               *PRG
$03        3     Unclosed user                  *USR
$04        4     Unclosed relative              Cannot occur

$A0      160     Deleted @ replacement          DEL
$A1      161     Sequential @ replacement       SEQ
$A2      162     Program @ replacement          PRG
$A3      163     User @ replacement             USR
$A4      164     Relative @ replacement         Cannot occur

$C0      192     Locked deleted                 DEL<
$C1      193     Locked sequential              SEQ<
$C2      194     Locked program                 PRG<
$C3      195     Locked user                    USR<
$C4      196     Locked relative                REL<

Note: It is possible to edit the file-type byte and get very unusual file types
appearing in the directory (SR?< is one possibility). However, these file types
have no practical use.

Enough esoterica for now. Let's get back to our example:

The next two bytes in the file entry are a pointer to where the first sector of
that particular file is stored on the diskette.

. 00: 12 04 82 11 00 48 4F 57 .....HOW
               ** **
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 0D 00 ........

This file starts on track 17 ($11), sector 0 ($00).

Next we have the file name.

. 00: 12 04 82 11 00 48 4F 57 .....HOW
                     ** ** **
. 08: 20 54 4F 20 55 53 45 A0  TO USE
      ** ** ** ** ** ** ** **
. 10: A0 A0 A0 A0 A0 00 00 00      ...
      ** ** ** ** **
. 18: 00 00 00 00 00 00 0D 00 ........

In this case our file is named "HOW TO USE". Note that file names are padded
out to 16 characters with shifted spaces ($A0) just like the diskette name. The
shifted spaces do not show as part of the file name, however, when the
directory is displayed.

. 00: 12 04 82 11 00 48 4F 57 .....HOW
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
                     ** ** **
. 18: 00 00 00 00 00 00 0D 00 ........

The next three bytes are unused except for relative file entries. For a
relative file bytes $15 (21) and $16 (22) point to the first set of side
sectors. Byte $17 (23) gives the record size with which the relative file was
created. This special file type will be examined in detail later.

The next four bytes are always unused and therefore null ($00).

. 00: 12 04 82 11 00 48 4F 57 .....HOW
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 0D 00 ........
      ** ** ** **

The following two bytes are reserved for use by the DOS during the save and
replace operation (@ replacement). Their function can only be viewed by
interrupting the drive during a SAVE "@0:file name",8 routine. This is not
recommended for obvious reasons. (During an @ replacement the file-type byte is
ORed with $20 first. A new copy of the file is then written to the disk. Bytes
28 ($1C) and 29 ($1D) contain the track and sector pointer to the start of the
new replacement file. At the end of the @ operation the sectors that held the
old file are marked as free in the BAM. The new track and sector pointer is
then moved from bytes 28 and 29 to bytes 3 ($03) and 4 ($04) respectively and
bytes 28 and 29 are zeroed again. The proper file type is then restored at byte
2. See Chapter 9 about the bug in the @ replacement command.)

. 00: 12 04 82 11 00 48 4F 57 .....HOW
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 0D 00 ........
                  ** **

The final two bytes in a file entry are the number of blocks it occupies on the
diskette. It is the sum of the leftmost byte (lo-byte) + the rightmost byte
(hi-byte) * 256.

. 00: 12 04 82 11 00 48 4F 57 .....HOW
. 08: 20 54 4F 20 55 53 45 A0  TO USE
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 0D 00 ........
                        ** **
                        LO HI

In our example, the file is (13 + 0 * 256) = 13 blocks long.

To be sure you understand the file entries work let's break out the first
sector of the test/demo directory to show each file entry. Remember that bytes
0 and 1 of each entry are unused with the exception of the first entry. Here
they represent a forward track and sector chain and have nothing to do with
that file in particular.


            1541TEST/DEMO

         TRACK 18 - SECTOR 01

          DIRECTORY ENTRY 1

. 00: 12 04 82 11 00 48 4F 57 .....HOW  File type = $82 = PRG
. 08: 20 54 4F 20 55 53 45 A0  TO USE   Starts on 17/1 ($11/$00)
. 10: A0 A0 A0 A0 A0 00 00 00      ...  Name: HOW TO USE
. 18: 00 00 00 00 00 00 0D 00 ........  File length: 13 BLOCKS

          DIRECTORY ENTRY 2

. 20: 00 00 82 11 03 48 4F 57 .....HOW  File type = $82 = PRG
. 28: 20 50 41 52 54 20 54 57  PART TW  Starts on 17/3 ($11/$03)
. 30: 4F A0 A0 A0 A0 00 00 00 O    ...  Name: HOW PART TWO
. 38: 00 00 00 00 00 00 05 00 ........  File length: 5 BLOCKS

          DIRECTORY ENTRY 3

. 40: 00 00 82 11 09 56 49 43 .....VIC  File type = $82 = PRG
. 48: 2D 32 30 20 57 45 44 47 -20 WEDG  Starts on 17/9 ($11/09)
. 50: 45 A0 A0 A0 A0 00 00 00 E    ...  Name: VIC-20 WEDGE
. 58: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

          DIRECTORY ENTRY 4

. 60: 00 00 82 13 00 46 2D 36 .....C-6  File type = $82 = PRG
. 68: 34 20 57 45 44 47 45 A0 4 WEDGE   Starts on 19/0 ($13/$00)
. 70: A0 A0 A0 A0 A0 00 00 00      ...  Name C-64 WEDGE
. 78: 00 00 00 00 00 00 01 00 ........  File length: 1 BLOCK

          DIRECTORY ENTRY 5

. 80: 00 00 82 13 01 44 4F 53 .....DOS  File type = $82 = PRG
. 88: 20 35 2E 31 A0 A0 A0 A0  5.1      Starts on 19/1 ($13/$01)
. 90: A0 A0 A0 A0 A0 00 00 00      ...  Name: DOS 5.1
. 98: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

          DIRECTORY ENTRY 6

. A0: 00 00 82 13 03 43 4F 50 .....COP  File type = $82 = PRG
. A8: 59 2F 41 4C 4C A0 A0 A0 Y/ALL     Starts on 19/3 ($13/03)
. B0: A0 A0 A0 A0 A0 00 00 00      ...  Name: COPY/ALL
. B8: 00 00 00 00 00 00 0B 00 ........  File length: 11 BLOCKS

          DIRECTORY ENTRY 7

. C0: 00 00 82 13 09 50 52 49 .....PRI  File type = $82 = PRG
. C8: 4E 54 45 52 20 54 45 53 NTER TES  Starts on 19/9 ($13/09)
. D0: 54 A0 A0 A0 A0 00 00 00 T    ...  Name: PRINTER TEST
. D8: 00 00 00 00 00 00 09 00 ........  File length: 9 BLOCKS

          DIRECTORY ENTRY 8

. E0: 00 00 82 10 00 44 49 53 .....DIS  File type = $82 = PRG
. E8: 4B 20 41 44 44 52 20 43 K ADDR C  Starts on 16/0 ($10/00)
. F0: 48 41 4E 47 45 00 00 00 HANGE...  Name:DISK ADDR CHANGE
. F8: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS


We will end our tour of the directory by displaying the next sector (track 18,
sector 4) which happens to end the directory chain ($00, $FF in bytes 0 and 1,
respectively). Notice that only seven directory entries are present in this
block. The last directory entry is a null entry. It will be converted into a
valid entry when the directory is expanded.


            1541TEST/DEMO

         TRACK 18 - SECTOR 04

. 00: 00 FF 82 10 01 44 49 52 .....DIR  File type = $82 = PRG
. 08: A0 A0 A0 A0 A0 A0 A0 A0           Starts on 16/1 ($10/01)
. 10: A0 A0 A0 A0 A0 00 00 00      ...  Name: DIR
. 18: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

. 20: 00 00 82 10 03 56 49 45 .....VIE  File type = $82 = PRG
. 28: 57 20 42 41 4D A0 A0 A0 W BAM     Starts on 16/3 ($10/03)
. 30: A0 A0 A0 A0 A0 00 00 00      ...  Name:VIEW BAM
. 38: 00 00 00 00 00 00 06 00 ........  File length: 6 BLOCKS

. 40: 00 00 82 10 07 43 48 45 .....CHE  File type = $82 = PRG
. 48: 43 4B 20 44 49 53 4B A0 CK DISK   Starts on 16/7 ($10/07)
. 50: A0 A0 A0 A0 A0 00 00 00      ...  Name: CHECK DISK
. 58: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

. 60: 00 00 82 10 0F 44 49 53 .....DIS  File type = $82 = PRG
. 68: 50 4C 41 59 20 54 26 53 PLAY T&S  Starts on 16/15 ($10/$0F)
. 70: A0 A0 A0 A0 A0 00 00 00      ...  Name: DISPLAY T&S
. 78: 00 00 00 00 00 00 0E 00 ........  File length: 14 BLOCKS

. 80: 00 00 82 14 02 50 45 52 .....PER  File type = $82 = PRG
. 88: 46 4F 52 4D 41 4E 43 45 FORMANCE  Starts on 20/2 ($14/$02)
. 90: 20 54 45 53 54 00 00 00  TEST...  Name: PERFORMANCE TEST
. 98: 00 00 00 00 00 00 09 00 ........  File length: 9 BLOCKS

. A0: 00 00 82 14 07 50 45 52 .....SEQ  File type = $82 = PRG
. A8: 55 45 4E 54 49 41 4C 20 UENTIAL   Starts on 20/7 ($14/$07)
. B0: 46 49 4C 45 A0 00 00 00 FILE ...  Name: SEQUENTIAL FILE
. B8: 00 00 00 00 00 00 05 00 ........  File length: 5 BLOCKS

. C0: 00 00 82 0F 01 52 41 4E .....RAN  File type = $82 = PRG
. C8: 44 4F 4D 20 46 49 4C 45 DOM FILE  Starts on 15/1 ($0F/$01)
. D0: A0 A0 A0 A0 A0 00 00 00      ...  Name: RANDOM FILE
. D8: 00 00 00 00 00 00 0D 00 ........  File length: 13 BLOCKS

. EO: 00 00 00 00 00 00 00 00 ........  NULL ENTRY
. E8: 00 00 00 00 00 00 00 00 ........
. F0: 00 00 00 00 00 00 00 00 ........
. F8: 00 00 00 00 00 00 00 00 ........


You will find four of the utilities listed in Appendix C particularly helpful
in furthering your understanding of the organization of a diskette. The first
program is DISPLAY TRACK & SECTOR. The hex dumps in this section were generated
using this utility. A hex dump can be sent either to the screen or printer.
When sent to the screen only half a page of the specified track and sector is
displayed at one time to prevent scrolling. Bytes 0 - 127 ($00 - $7F) are
displayed first followed by bytes 128 - 255 ($80 - $FF). Use this program for
your own experimentation. The second program is DISPLAY A BLOCK AVAILABILITY
MAP. It portrays the BAM in a two-dimensional representation. The diskette
name, ID, DOS version, and blocks free are also displayed. The third program is
VIRTUAL DIRECTORY. It displays a directory in its entirety including scratched
files. Output can be directed to a printer by changing the OPEN 4,3 statement
in line 440 to OPEN 4,4. The last program, DISPLAY A CHAIN, traces a file
chain. The chain of sectors may be viewed on the screen or sent to the printer.

The programming techniques that are used in these sample programs will be
partially explained in later sections.

Now that we've seen how the directory is kept, let's look at how the different
types of files are actually stored on a diskette. We'll start by looking at a
program file.


4.5 Program File Storage

The most common type of file is a program file, PRG. It is designated by an $82
in the directory. Program file structure is quite simple. Diagrammatically, the
first sector (block) in a program file looks like this.

+-------+--------+------+------+---------------------+
| TRACK | SECTOR | LOAD | LOAD | THE FIRST 252 BYTES |
| LINK  | LINK   |  LO  |  HI  |   OF YOUR PROGRAM   |
+-------+--------+------+------+---------------------+


   Byte    Purpose
---------  --------------------------------------------------------------------

    0      Track of the next block in this file
    1      Sector of the next block in this file
    2      Lo-byte of the load address
    3      Hi-byte of the load address

  4-255    The first 252 bytes of the program

The first pair of bytes are the pointer to the track and sector of the next
block in the file. Technically, this is known as a "forward pointer." It points
ahead to the next sector in the file. All Commodore files use this type of
pointer.

The second pair of bytes is the "load address" of the file in lo-byte/hi-byte
form. They indicate where the program is to be loaded into memory. A BASIC
program that was saved from a C64 will have a $01 and a $08 in these two
locations. This indicates that the program is to be loaded into memory starting
at memory location $0801 (remember it is in lo-byte/hi-byte form). In decimal
notation this is memory location 2049 — the start of BASIC on a C64.

Have you ever wondered about the significance of the ",1" in the command LOAD
"name",8,1? It determines whether or not a program is "relocated" when it is
loaded into memory. If you do not specify the ",1", the C64 will ignore the
load address at the start of the file and load the program starting at memory
location $0801 (2049). When the ",1" is present, the C64 (or VIC-20) will pay
attention to the load address and load the program into memory starting at the
location specified by bytes $02 and $03.

The remaining sectors, except the last one, look like this:

+-------+--------+--------------------+
| TRACK | SECTOR | THE NEXT 254 BYTES |
| LINK  | LINK   |  OF YOUR PROGRAM   |
+-------+--------+--------------------+


   Byte    Purpose
---------  --------------------------------------------------------------------

    0      Track of the next block in this file
    1      Sector of the next block in this file

  2-255    The next 254 bytes of the program

The last block in a program file is special because:

1. It is the last sector.
2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00.
The first byte is normally the track link. Since there is no track 0, the DOS
knows that this is the last sector in the file. The second byte indicates the
position of the last byte that is part of the program file. Any bytes beyond
this position are garbage.

Diagrammatically, the last sector in a program file looks like this:

+------+------+-----------------+---------+
| NULL | LAST | THE FINAL BYTES | GARBAGE |
| $00  | BYTE | OF YOUR PROGRAM |         |
+------+------+-----------------+---------+


   Byte    Purpose
---------  --------------------------------------------------------------------

    0      Null byte to indicate that this is the last sector
    1      Number of bytes to read from this sector (N)

   2-N     The last (N-2) bytes of the program
(N+1)-255  Garbage

Let's examine the program file "DIR" on your 1541TEST/DEMO disk. DIR appears in
the directory on track 18, sector 04. The directory entry looks like this:

         TRACK 18 - SECTOR 04

. 00: 00 FF 82 10 01 44 49 52 .....DIR
. 08: A0 A0 A0 A0 A0 A0 A0 A0
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 04 00 ........

From the entry we see that "DIR" starts at track 16 ($10), sector 01 ($01) and
that the file is four blocks long (4 + 0 * 256).

. 00: 00 FF 82 10 01 44 49 52 .....DIR
               ** **
. 08: A0 A0 A0 A0 A0 A0 A0 A0
. 10: A0 A0 A0 A0 A0 00 00 00      ...
. 18: 00 00 00 00 00 00 04 00 ........
                        ** **

Let's look at the first block in this file.

TRACK 16 - SECTOR 01

. 00: 10 0B 01 04 0D 04 04 00 ........
. 08: 9F 32 2C 38 2C 31 35 00 .2,8,15.
. 10: 1E 04 05 00 99 22 93 22 ....."."
. 18: 3A 89 20 31 30 30 30 30 :. 10000
. 20: 00 2E 04 0A 00 9F 31 2C ......1,
. 28: 38 2C 30 2C 22 24 30 22 8,0,"$0"
. 30: 00 3C 04 14 00 A1 23 31 .<....#1
. 38: 2C 41 24 2C 42 24 00 4A ,A$,B$.J
. 40: 04 1E 00 A1 23 31 2C 41 ....#1,A
. 48: 24 2C 42 24 00 58 04 28 $,B$.X.(
. 50: 00 A1 23 31 2C 41 24 2C ..#1,A$,
. 58: 42 24 00 60 04 32 00 43 B$...2.C
. 60: B2 30 00 77 04 3C 00 8B .0...<..
. 68: 20 41 24 B3 B1 22 22 20  A$..""
. 70: A7 20 43 B2 C6 28 41 24 . C..(A$
. 78: 29 00 94 04 46 00 8B 20 )...F..
. 80: 42 24 B3 B1 22 22 20 A7 B$.."" .
. 88: 20 43 B2 43 AA C6 28 42  C.C..(B
. 90: 24 29 AC 32 35 36 00 AF $).256..
. 98: 04 50 00 99 22 12 22 CA .P..".".
. A0: 28 C4 28 43 29 2C 32 29 (.(C),2)
. A8: 3B A3 33 29 3B 22 92 22 ;.3);"."
. B0: 3B 00 C9 04 5A 00 A1 23 ;...Z..#
. B8: 31 2C 42 24 3A 8B 20 53 1,B$:. S
. C0: 54 B3 B1 30 20 A7 20 31 T..0 . 1
. C8: 30 30 30 00 DE 04 64 00 000.....
. D0: 8B 20 42 24 B3 B1 C7 28 . B$...(
. D8: 33 34 29 20 A7 20 39 30 34) . 90
. E0: 00 00 05 6E 00 A1 23 31 ......#1
. E8: 2C 42 24 3A 8B 20 42 24 ,B$:. B$
. F0: B3 B1 C7 28 33 34 29 A7 ...(34).
. F8: 20 99 42 24 3B 3A 89 31  .B$;:.1

Not very recognizable is it? Remember this is C64 internal BASIC not a BASIC
listing. Bytes 0 and 1 are of interest. They are the track and sector link that
point to the next block in the program file. In this case, they point to track
16 ($10), sector 11 ($0B). Since this is the first data block of the file,
bytes 2 and 3 are also important. They are the load address. We can see that
the load address is $0401 or 1025 decimal. This file was written on a PET. (The
start of BASIC memory on the C64 is at $0801. The VIC-20 begins at $1001,
$1201, or $0401 depending on the amount of external memory.) DIR will require a
straight relocating load, i.e., LOAD "DIR",8. If you used a LOAD "DIR", 8,1
command, the program would be loaded into the screen RAM of the C64. NOTE: If
you load this program properly, you will NOT be able to get it to VERIFY
correctly. The reason is that the internal BASIC links were changed when the
program was relocated.


. 00: 10 0B 01 04 0D 04 04 00 ........
      ** ** ** **

Let's follow the forward chain to track 16, sector 11 and take a look at the
start of the second block in our file.


         TRACK 16 - SECTOR 11

. 00: 10 02 31 30 00 1C 05 78 ..10....
. 08: 00 A1 23 31 2C 42 24 3A ..#1,B$:
. 10: 8B 20 42 24 B2 C7 28 33 . B$..(3

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nothing much of interest here. Let's chain to track 16 ($10), sector 02 ($02)
and take a look at the start of the next block.


         TRACK 16 - SECTOR 02

. 00: 10 0C B2 22 22 3A 99 22 ..."":."
. 08: 3E 22 3B 00 1A 06 AB 0F >";.....
. 10: A1 42 24 3A 8B 42 24 B2 .B$:.B$.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Again, nothing much of interest. Chain to track 16 ($10), sector 12 ($0C).


         TRACK 16 - SECTOR 12

. 00: 00 68 8B 20 41 24 B2 22 ... A$."
. 08: 44 22 20 A7 20 31 30 00 D" . 10.
. 10: 2D 07 3C 28 8B 20 41 24 -.<(. A$
. 18: B2 22 2E 22 20 B0 20 41 ."." . A
. 20: 24 B2 22 3E 22 20 B0 20 *.">" .
. 28: 41 24 B2 22 3E 22 20 A7 A$.">" .
. 30: 20 34 30 30 30 00 3E 07  4000.>.
. 38: 46 28 8B 20 41 24 B2 22 F(. A$."
. 40: 51 22 20 A7 20 80 00 52 Q" . ..R
. 48: 07 50 28 8B 20 41 24 B2 .P(. A$.
. 50: 22 53 22 20 A7 20 35 30 "S" . 50
. 58: 30 30 00 5E 07 F7 2A 89 00. ..*.
. 60: 20 31 30 31 30 30 00 00  10100..
. 68: 00 A0 00 A1 20 54 24 3A .... T$:
. 70: 8B 20 54 24 B3 B1 22 22 . T$..""
. 78: 20 A7 20 8D 20 32 30 30  . . 200

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we're cooking. This is the last sector of the file. How can we tell? The
track of the next block in the file is 0 ($00). But what about the sector link?
It's a misnomer. The sector link in the last block is actually a byte count. It
informs the DOS that only bytes 2 through 104 ($68) are important in this
example. Recall that an end of file in BASIC is designated by three zeros in a
row. An End-or-Identify (EOI) signal will be sent once byte 104 has been
transferred across the serial bus. When the C64 receives this EOI signal, the
status variable, ST, will be set to a value of 64. (Any further attempt to read
a byte will cause the drive to time out.) Here's the tail end of our program.
The three null bytes, ($00), at $66/7/8 are the last three bytes in our program
file.

. 00: 00 68 8B 20 41 24 B2 22 ... A$."
. 08: 44 22 20 A7 20 31 30 00 D" . 10.
. 10: 2D 07 3C 28 8B 20 41 24 -.<(. A$
. 18: B2 22 2E 22 20 B0 20 41 ."." . A
. 20: 24 B2 22 3E 22 20 B0 20 *.">" .
. 28: 41 24 B2 22 3E 22 20 A7 A$.">" .
. 30: 20 34 30 30 30 00 3E 07  4000.>.
. 38: 46 28 8B 20 41 24 B2 22 F(. A$."
. 40: 51 22 20 A7 20 80 00 52 Q" . ..R
. 48: 07 50 28 8B 20 41 24 B2 .P(. A$.
. 50: 22 53 22 20 A7 20 35 30 "S" . 50
. 58: 30 30 00 5E 07 F7 2A 89 00. ..*.
. 60: 20 31 30 31 30 30 00 00  10100..
. 68: xx xx xx xx xx xx xx xx .

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What about the rest of the block? Ignore it. It is garbage. The DOS does not
zero out a buffer before it begins filling it with new information sent from
the computer. As a result, the last block in a file, which is almost never
filled with new information, is padded with whatever happened to be left in the
buffer from a previous read or write operation. There are two exceptions to the
rule, namely, the directory and relative files. A partial directory block is
always padded with nulls ($00). Moreover, it always appears as a full block.
Bytes 0 and 1 of the last directory block will contain a $00 and a $FF,
respectively. Relative file structure will be explained shortly.


4.6 Sequential File Storage

The format of a sequential file is very straightforward. All the sectors,
except the last one, look like this:

+-------+--------+-------------------+
| TRACK | SECTOR | 254 BYTES OF DATA |
| LINK  | LINK   |                   |
+-------+--------+-------------------+


Byte      Purpose
--------  --------------------------------------------------------------------

0         Track of the next block in this file
1         Sector of the next block in this file

2-255     254 bytes of data

The last block in a sequential file is special for two reasons:

1. It is the last sector.
2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00.
The first byte is normally the track link. Since there is no track 0, the DOS
knows that this is the last sector in the file. The second byte indicates the
position of the last byte in the file. Any bytes beyond this position are
garbage.

Diagrammatically, the last sector in the file looks like this:


+------+------+-------------------------+---------+
| NULL | LAST | THE FINAL DATA BYTES IN | GARBAGE |
| $00  | BYTE |   YOUR SEQUENTIAL FILE  |         |
+------+------+-------------------------+---------+


Byte       Purpose
---------  --------------------------------------------------------------------

0          Null byte to indicate this is the last sector
1          Position of the last byte in the file (N)

2-N        The last N-2 bytes of the sequential file
(N+1)-255  Garbage

