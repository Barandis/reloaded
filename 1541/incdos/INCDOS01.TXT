PROJECT HEADER
---------------

Welcome to Project 64 Reloaded!

The goal of Project 64 is to preserve Commodore 64 related documents in
electronic text format that might otherwise cease to exist with the rapid
advancement of computer technology and declining interest in 8- bit computers
on the part of the general population. Project 64 Reloaded maintains a
publicly available, revision controlled repository of all the documents it
took over from the original Project 64. At the time of writing, the
repository is hosted by GitHub and made available to the public under
following URL:

https://github.com/Project-64/etext

a simplified interface to the documents is at the time of writing available
under

http://e4aws.silverdr.com/project64/

Project accepts donations, which are meant to help keeping project members
motivated as well as fund project related purchases:

* copies of books or documents
* processing equipment (high quality automated scanner, binding equipment)
* processing software (Commercial OCR/extensions)
* professional services (unbinding, restoration, rebinding)

At the time of writing donations are accepted in the form of electronic
currency:

http://e4aws.silverdr.com/resources/bitcoin/QRproject64donation.png

or as direct donations/sponsorship of the above listed. For direct donations,
please contact project members through project web pages.


DISCLAIMERS
---------------

Extensive efforts were made to preserve the contents of the original
document. However, certain portions, such as diagrams, program listings, and
indexes may have been either altered or sacrificed due to the limitations of
plain vanilla text. Diagrams may have been eliminated where ASCII-art was not
feasible. Program listings may be missing display codes where substitutions
were not possible. Tables of contents and indexes may have been changed from
page number references to section number references. Please accept our
apologies for these limitations, alterations, and possible omissions.

The author(s) of the original document and members of Project 64 make no
representations about the accuracy or suitability of this material for any
purpose. This etext is provided "as-is". Please refer to the warantee of the
original document, if any, that may included in this etext. No other
warantees, express or implied, are made to you as to the etext or any medium
it may be on. Neither the author(s) nor the members of Project 64 will assume
liability for damages either from the direct or indirect use of this etext or
from the distribution of or modification to this etext. Therefore if you read
this document or use the information herein you do so at your own risk.


DOCUMENT HEADER
---------------

The Project 64 etext of Inside Commodore DOS by Richard Immers, Ph.D. and
Gerald G. Neufeld, Ph.D. second edition. Converted to etext by Silver Dream !
and Pinacolada64.

INCDOS01.TXT (WIP), April 2014


DOCUMENT NOTES
---------------

The following elements specifically and purposefully do not follow the
formatting of the original book:

* Notes - the original notes begin with "NOTE:" and are either fully or
  partially italicised. We follow this only when they are inline with other
  parts of the text. Whenever they are on a line of their own, we don't
  follow this for the sake of plain text readibility.
* Fixed width - lines printed in fixed width font in the original book are
  left-flush justified. When read as text/plain, you'll see them four spaces
  to the right for Markdown compatibility.
* Chapter headers and titles are formatted in one line rather than two.
* Chapter and section header lines are prepended with "#" marks
* Program listins originally formatter for 40 columns are reformatted to full
  lines wherever possible for better readability and easier processing

---
﻿
                                  INSIDE
                                COMMODORE
                                   DOS
﻿
﻿



                                  INSIDE
                                COMMODORE
                                   DOS

                                    by

                           Richard Immers, Ph.D.
                           Adrian Public Schools
                             Adrian, Michigan

                                   and

                         Gerald G. Neufeld, Ph.D.
                           Brandon University
                            Brandon, Manitoba
                                 Canada


                        Technical Illustrations by
                            Diane M. Corralejo

                               DATAMOST, Inc.
                19821 Nordhoff Street, Northridge, CA 91324
                              (818) 709-1202
﻿



                        First Printing, July 1984
                      Second Printing, February 1985







                      RESTON PUBLISHING COMPANY, INC.
                         A Prentice-Hall Company
                            Reston, Virginia

                           ISBN 0-8359-3091-2

                    Copyright © 1984 by DATAMOST, Inc.
                           All Rights Reserved

This manual is published and copyrighted by DATAMOST, Inc. All rights are
reserved by DATAMOST, Inc. Copying, duplicating, selling or otherwise
distributing this product is hereby expressly forbidden except by prior
written consent of DATAMOST, Inc.

The words COMMODORE, CBM, COMMODORE 64, VIC-20, VIC-1541 and the Commodore
logo are registered trademarks of Commodore Business Machines, Inc.

Commodore Business Machines was not in any way involved in the writing or
other preparation of this manual, nor were the facts presented here reviewed
for accuracy by them.

The information presented in this manual is the result of intensive study of
the disassembly of the 1541 DOS. Every effort has been made to provide
error-free information. However, neither the authors nor DATAMOST, Inc. can
accept responsibility for any loss or damage, tangible or intangible,
resulting from use or improper or unintended use of this information.

                                                       Printed in U.S.A.
﻿


                        ACKNOWLEDGEMENTS

A manual like this one would not be possible without a great deal of
technical assistance. Mike Todd's Disk File column in the *ICPUG Newsletter*
proved to be an invaluable source of insight into the inner workings of
Commodore's DOS. Raeto West's book, *Programming the PET/CBM*, was a constant
companion. Jim Butterfield's numerous articles also provided valuable bits
and pieces of information. Brad Templeton's POWER™ system and PAL™ assembler
made the development of the programs in this manual a real joy. These
packages are commercially available from Professional Software Inc. In
addition, both the PAL disassembler and MICROMON were used as tools for
disassembling the 1541 DOS.

We would also like to acknowledge the patience and forebearance of our
families and friends. Without their support, producing this manual would have
been considerably more difficult. Mike Louder of DATAMOST, Inc. also provided
tremendous support for its production.

Finally, we would like to extend a special note of thanks to Dr. Tom MacNeil
and Nancy Neufeld for their diligent work in proofreading this manual.

This manual was written on a Commodore computer system using the WordPro 4
Plus word processing system. The WordPro Plus™ Series is commercially
available from Professional Software Inc. This sophisticated word processing
system made editing and last minute revisions much easier.
﻿
﻿



                        TABLE OF CONTENTS

    Chapter 1 - INTRODUCTION
                A Brief Word About the Programs
                How to Type in the Programs

    Chapter 2 - USING THE 1541'S DOS
                The Purpose of DOS
                Communicating with the 1541
                The Command Channel
                Using the Command Channel
                Diskette Housekeeping

    Chapter 3 - DISKETTE FORMATTING
                Layout of Tracks and Sectors
                Layout of a Sector
                The Header Block
                The Data Block

    Chapter 4 - DISKETTE ORGANIZATION
                Information Management
                The Directory You See
                The Block Availability Map
                The Directory Entries
                Program File Storage
                Sequential File Storage
                Relative File Storage
                User File Storage
                Deleted File Storage
                Locked Files

    Chapter 5 - DIRECT-ACCESS PROGRAMMING
                Introduction to Direct-Access Programming
                Beginning Direct-Access Programming
                Block-Read Command
                Buffer-Pointer Command
                Block-Write Command
                Memory-Read Command
                Memory-Write Command
                Block-Allocate Command
                Block-Free Command
                Memory-Execute Command
                Block Execute Command
                Direct-Access Entomology

    Chapter 6 - INTERMEDIATE DIRECT-ACCESS PROGRAMMING

    Chapter 7 - DOS PROTECTION
                Commodore's Data Encoding Scheme
                Checksums
                Description of DOS Error Messages
                Analyzing a Protected Diskette
                Duplicating a Protection Scheme
                How to Create 21 Errors on a Full Track
                How to Create a 21 Error on a Single Sector
                How to Create a 23 Error on a Single Sector
                How to Duplicate a 23 Error on a Single Sector
                How to Create 23 Errors on a Full Track
                How to Create 20 Errors on a Full Track
                How to Create 27 Errors on a Full Track
                How to Create a 22 Error on a Single Sector
                How to Duplicate a 22 Error on a Single Sector
                How to Format a Diskette with Multiple IDs
                How to Backup a DOS Protected Diskette
                How to Copy a File

    Chapter 8 - GETTING OUT OF TROUBLE
                Unscratching a File
                Recovering a Soft Sector
                Recovering a Hard Sector
                Recovering a Relative File
                Recovering an Entire Diskette
                Recovering a Physically Damaged Diskette
                Recovering an Unclosed File
                Recovering from a Short New
                Recovering from a Full New

    Chapter 9 - OVERVIEW OF THE 1541 DOS
                Introduction to 1541 DOS
                The Hard Working 6502
                Major IP Routines
                Using the IP Routines
                Major FDC Routines
                Using the FDC Routines
                The Recording Process
                Block Diagram of the 1541
                Writing Data to a Diskette
                Reading Data From a Diskette
                Summary Bugs in DOS 2.6
                Write Incompatibility with 4040
                Late News

    Appendix A - 1541 RAM VARIABLE DEFINITIONS

    Appendix B - ANALYSIS OF THE 1541's ROM

    Appendix C - PROGRAM LISTINGS

    Appendix D - MATHEMATICAL CONVERSION ROUTINES

    Index
﻿
                    *Ignorance is a precious thing.*
                 *Once lost, it can never be regained.*
﻿
# CHAPTER 1 - INTRODUCTION

This manual is intended to supplement the documentation provided in the *1541
User's Manual*. Although this manual is primarily designed to meet the needs
of the intermediate to advanced programmer, it will also be of interest to
the novice Commodore user who wants to know more about how his 1541 disk
drive works. This manual is not intended to replace the documentation
provided by Commodore Business Machines, Inc. and the reader is assumed to be
relatively familiar with the contents of the *1541 User's Manual*. For the
sake of continuity and clarity, some of the information covered in the *1541
User's Manual* is also presented here. However, the majority of the
information presented in this manual is original and is the result of
intensive disassembly and annotation of the 1541's DOS by the authors. Some
information is based on articles and notes published in a variety of
publications as well as discussions with other knowledgeable disk experts.

This manual was not prepared with the assistance of Commodore Business
Machines, Inc. Although we cannot guarantee the accuracy of all the
information presented in this manual, the material has been thoroughly
researched and tested.

There were several reasons for writing *Inside Commodore DOS:*

1. To correct errors and omissions in the *1541 User's Manual.*
2. To help you make more effective use of your disk drive.
3. To provide complete information on diskette formatting.
4. To provide complete information on the storage of files.
5. To allow you to read and write data in non-standard ways.
6. To help you make a backup copy of your "protected" diskettes.
7. To help you recover damaged diskettes.
8. To help you understand the operation of your disk drive.

Although this manual focuses primarily on the 1541 disk drive, much of the
information also applies to other Commodore disk drives.


## 1.1 A Brief Word About the Programs

This book contains listings for 46 ready-to-use programs written in BASIC.
These programs are copyrighted. They may NOT be used commercially, in whole
or in part, period. Since many of the programs are long, typing them all in
would be a time consuming, tedious task. Feel free to share your typing
efforts with a friend who has also purchased a copy of this book. In return,
we simply ask that you do not share a program with someone who does not own a
legitimate copy of this book.

The programs in this book are disk utilities. They do not use flashy graphics
or sound. Rather, they are extremely powerful tools. Remember, any tool can
be dangerous if it is used improperly. Be sure that you know what you are
doing before you use a given program. Always experiment with a program on a
test diskette before you actually use it on one that contains valuable
programs or data. Practice makes perfect.

Each program was individually tested on a variety of 1541 disk drives having
a wide range of serial numbers. Moreover, each program always worked
perfectly. Unfortunately, it is impossible to guarantee that a particular
program will work with your model. If a given program does not seem to work
properly, check your typing carefully. Any errors, especially in the DATA
statements which contain a machine language program, will produce problems.

As a courtesy to the more advanced programmer, we have also included the
source listings for each machine language routine A source listing
immediately follows a related BASIC program listing and has a file name
ending in ".PAL". It is for use with the PAL assembler. *Note: If you are
using a different assembler, you may have to make some minor changes.*

The programs in this book were designed to be not only useful and beneficial,
but instructive as well. Many of them illustrate the "state of the art" in
the use of Commodore's direct-access disk commands. Enjoy!

## 1.2 How to Type in the Programs

Program listings in books and magazines often suffer from two problems:
typographical errors that occur when the program is retyped into a word
processor and the readability of Commodore's control characters (e.g., the
reverse field heart that means Clear Screen). To overcome these problems, the
program listings for this book were created using a special "lister" program.
This lister program took a working BASIC program and converted it into a
WordPro™ file. At the same time, control characters were spelled out in words
and surrounded by curly brackets. For example, a reverse field heart was
converted to {CLR}. The table below summarizes the listing conventions, the
corresponding control characters, and the proper key/keys to press on your
C64 or VIC-20.

    When You See          What It Represents      What You Type
    ----------------      --------------------    --------------
    {CLR}                 Clear Screen            Hold down SHIFT and press
                                                  CLR/HOME
    {HOME}                Home Cursor             Press CLR/HOME
    {DOWN}                Cursor Down             Press CRSR/DOWN
    {UP}                  Cursor Up               Hold down SHIFT and press
                                                  CRSR/UP
    {RIGHT}               Cursor Right            Press CRSR/RIGHT
    {LEFT}                Cursor Left             Hold down SHIFT and press
                                                  CRSR/LEFT
    {RVS}                 Reverse Field ON        Hold down CTRL and press 9
    {ROFF}                Reverse Field OFF       Hold down CTRL and press 0

NOTE 1: When a number appears inside the curly brackets, it means you repeat
the control character immediately to the left of the number that many times.
For example:

{DOWN 5} means to press CRSR/DOWN five (5) times.

NOTE 2: All programs have been listed in a column 40 characters wide. Except
where special characters have been spelled out between curly brackets, the
lines are listed exactly as they appear on a Commodore 64 display. Spaces
must be typed in as listed. Where necessary, count the character columns to
determine the appropriate number of spaces.

Happy hunting and pecking!
﻿
﻿
# CHAPTER 2 - USING THE 1541'S DOS

## 2.1 The Purpose of a DOS

A disk operating system (DOS) is a machine language program that controls a
disk drive. It does several different tasks:

1. Handling communications between a disk drive and a computer.
2. Carrying out housekeeping chores such as formatting a diskette.
3. Managing the storage of information on a diskette.
4. Reading and writing information onto a diskette's surface.

In many computer systems, a DOS is loaded into the main computer's memory
from diskette when the computer is first switched on. In this type of system
many of the tasks are carried out using the computer's microprocessor and
RAM. Commodore uses a different approach. All of Commodore's disk drives are
intelligent peripherals. They do not have to use the computer's resources;
they have their own. For example, the 1541 disk drive contains its own 6502
microprocessor, 2K of RAM, two 6522 I/O chips, and a DOS program permanently
stored in 15.8K of ROM.

The advantages of having an intelligent disk drive are:

1. The DOS does not use any of the computer's memory.
2. Some disk operations can be carried out independently from the CPU.
3. Disk operations do not slow down processing.
4. One disk drive can be shared among several computers.

The disadvantages of having an intelligent disk drive are:

1. It is very difficult to customize DOS routines.
2. You must replace the ROMs to convert to a new version of DOS.


## 2.2 Communicating with the 1541

Your Commodore 64 or VIC-20 can communicate with your 1541 disk drive in
several ways:

1. Through the LOAD, SAVE, and VERIFY commands.
2. Through I/O using the command channel.
3. Through I/O using data communication channels.

Let's examine each of these in greater detail.

1. LOAD, SAVE, and VERIFY commands:

These BASIC commands are used to store and retrieve programs on the Commodore
tape and disk drives. They are designed for ease of use, even by the novice.
The BASIC interpreter in the computer interprets these commands and sends the
disk drive the necessary information over the serial bus.

2. I/O using the command channel:

The command channel is used to send messages to the disk drive to carry out
disk operations like: formatting a blank diskette, erasing an unwanted file,
renaming a file, etc. These operations are often referred to as disk
housekeeping. The command channel is also used to input messages, such as the
current error status of the drive, generated by the DOS. For more details on
how to use the command channel, see Section 2.4.

3. I/O using data communication channels:

The 1541 DOS supports a variety of kinds of files: program files, sequential
files, relative files, user files, and direct-access files. The storage and
retrieval of information in files is carried out using a data communication
channel. Although this manual provides detailed information regarding how
files are stored and organized, no attempt is made to teach you how to
develop programs that make extensive use of file handling. We would encourage
readers who are interested in file handling techniques to refer to Jim
Butterfield's series of articles in *COMPUTE!.* The only I/O applications
discussed in this manual are those relating to direct-access programming (see
Chapter 5).

Since the rest of this manual makes extensive use of the command channel,
let's examine it in some detail.

## 2.3 The Command Channel

The command channel (channel number 15) is an important communication link
between your computer and the 1541 disk drive. It has several important
functions. You can use it to:

1. Monitor the error status of the drive to ensure that everything is
operating properly.

2. Send commands that direct the DOS to perform various housekeeping chores
associated with disk handling.

3. Send commands that direct the DOS to read or write information to specific
areas on a diskette.

This chapter focuses on the first two of these uses. Chapter 5 provides more
detail on reading or writing to a diskette.

## 2.4 Using the Command Channel

Using the command channel is easy. Just follow these steps:

1. Establish communications using an OPEN statement.
2. Send commands to the DOS using a PRINT# statement.
3. Read DOS messages using a GET# or INPUT# statement.
4. Close the channel using a CLOSE statement when you are finished.

Let's go over each step to ensure that you know exactly what to do.

### 1. Establishing communications using an OPEN statement.

In order to establish a communication channel between your computer and your
1541 disk drive, you use an OPEN statement. An OPEN statement is a BASIC
command which looks like this:

    SYNTAX:         OPEN file#, device#, channel#
    EXAMPLE:        OPEN 15, 8, 15

where

file#           = the logical file number (1-127)
device#         = the device number (8 for a stock 1541)
channel#        = the channel number or secondary address (2-15)

NOTE:

* Channel numbers 0 & 1 are reserved for use by the DOS.
* Channel numbers 2-14 are data communications channels.
* Channel number 15 is the command channel.

The OPEN statement can be used either in immediate mode (typed and executed
directly from the keyboard) or under program control (embedded in a program).

In the example above (OPEN 15, 8, 15) we opened logical file number 15 on the
C64 to device number 8 (the disk drive) through channel 15 (the command
channel).

### 2. Sending commands to the DOS using a PRINT# statement.

In order to send commands from your computer to the 1541, you use a PRINT#
statement. A PRINT# statement is a BASIC command which looks like this:

    SYNTAX:         PRINT# file#, "command"
    EXAMPLE:        PRINT#15, "N0:MY DISKETTE,MD"

where

* file# = the logical file number you used when you opened the command channel
* command = the disk command to be sent to the DOS

NOTE: The statement is PRINT# not PRINT #. You *must not* put a space before
the # sign. Spaces following the # sign are always optional. DO NOT use ?# as
an abbreviation either. The correct abbreviation is pR (p then SHIFTED R).

In this example, the disk command is "N0:MY DISKETTE,MD". This command causes
the DOS to prepare the blank diskette in the drive for first-time use.

Although there are many different disk commands, they fall into two groups:

1. Commands related to disk housekeeping.
2. Commands to read or write data to a diskette or the disk drive's RAM.

The disk housekeeping commands are discussed in the next part of this
chapter. The commands relating to reading or writing data are discussed in
Chapter 5 on Direct-Access Programming.

### 3. Reading DOS messages using a GET# or an INPUT# statement.

You may use either an INPUT# or a GET# statement to read the command channel
and access any messages or data prepared for the computer by the DOS. Both
INPUT# and GET# statements are BASIC commands. They look like this:

    SYNTAX:         INPUT# file#, variable list
                    GET# file#, variable list

    EXAMPLE:        INPUT# 15, EN, EM$, ET, ES
                    GET# 15, A$

where

* file# = the logical file number you used when you opened the command channel
* variable list = one or more variable names separated by commas

NOTE: As was noted for PRINT# above, the BASIC statements are INPUT# and
GET#, not INPUT # and GET #. You *must not* put a space before the # sign.
Spaces following the # sign are always optional. Neither the INPUT# statement
nor the GET# statement can be used in immediate mode (typed and executed
directly from the keyboard). They must be included within a program.

The INPUT# command and the GET# command operate in much the same way as the
more familiar INPUT and GET commands. INPUT# always reads as far as the next
carriage return character while GET# reads a single byte of information.
Generally, GET# is used in direct-access programming and INPUT# is used only
for monitoring the drive's error status as indicated immediately below.

You can check the error status of your disk drive using the command channel.
The DOS monitors every disk operation as it is carried out and prepares a
status report indicating whether or not the operation was completed
successfully. The report consists of an error code number, an English
language message, and the track and sector where the problem, if any, was
encountered. Here is a subroutine that checks the error status.

    100 OPEN 15,8,15 : REM THE OPEN COMMAND CHANNEL
            .       .       .
    500 INPUT#15,EN,EM$,ET,ES : REM INPUT THE ERROR STATUS
    51O IF EN < 20 THEN RETURN : REM NO ERROR ENCOUNTERED
    520 PRINT EN;EM$;ET;ES : REM PRINT THE ERROR STATUS ON SCREEN
    530 CLOSE 15 : END : REM ABORT ON BAD STATUS

Line 100 opens the command channel. It is a good idea to open the command
channel at the beginning of your program and leave it open until the end.
Line 500 inputs the status report. The error code number is stored in EN, the
message in EM$, the track in ET, and the sector in ES. Error codes less than
20 may be ignored (line 510). A complete list of the error codes and messages
is contained in the back of your *1541 User's Manual*. A detailed explanation
of the nature and cause of many of these errors is provided in Chapter 7 on
Disk Protection.

### 4. CLOSE the command channel when you are done.

After you have finished using the command channel, it should be closed.
Recall that the OPEN command has three parameters: the logical file number,
the device number, and the channel number. The CLOSE command has only one,
the logical file number. It looks like this:

    SYNTAX:         CLOSE file#
    EXAMPLE:        CLOSE 15

where

file# = the logical file number you used when you opened the command channel

NOTE: Loading, running, or editing a program closes down all communication
channels automatically. The command channel is closed properly in each
instance. However, data channels are aborted rather than closed. When a data
channel is aborted, the file is NOT CLOSED properly on the disk drive. You do
not have to close the command channel after the issuance of every command. If
you forget to close it, the worst that can happen is a ?FILE OPEN ERROR when
you attempt to open it again. However, you should get into the habit of
always closing a file when you are finished using it. You won't get into
trouble leaving the command channel open, but you may lose an important data
file if you leave a data communication channel open.


## 2.5 Disk Housekeeping

As your collection of programs grows, you will have to do some housekeeping
to keep things in shape. Disk housekeeping chores include the following:

1. Preparing a blank diskette for first-time use.
2. Erasing the contents of a diskette currently in use.
3. Initializing a diskette.
4. Renaming a file.
5. Scratching or erasing a file.
6. Copying a file.

These operations are carried out by the DOS in response to commands sent to
the drive using the command channel as indicated above. Once a disk
housekeeping command is issued, the disk drive will carry out the task
without further intervention by the computer. This means that you could edit
or even RUN a program in RAM while the disk drive busily formats or validates
a diskette. This is not really spooling. It occurs because the 1541 is an
intelligent peripheral. The only thing that will cause your computer to wait
for the disk drive to complete its task is your attempting to perform another
disk operation. This includes closing the command channel.

Let's take a look at the disk commands used for housekeeping. NOTE: If you
are using the DOS SUPPORT program that came on your 1541TEST/DEMO, the syntax
for these disk commands is remarkably shorter. The > or @ keys are used to
send a command to the disk drive. They take the place of the PRINT#
statement. In addition, you do not have to open or close the command channel
or embed the disk command in quotation marks. The DOS SUPPORT program will do
this automatically for you. The DOS 5.1 syntax can be used only in immediate
mode, however. It cannot be used in a program or a ?SYNTAX ERROR will result.


### The New Command

When a fresh diskette is taken from its storage envelope, the 1541 cannot
recognize it. The diskette must be formatted or newed prior to first-time
use. Formatting or newing a diskette is performed by the DOS. The DOS
proceeds to write concentric tracks made up of blocks/sectors to the
diskette. In addition, a directory is set up, wherein the drive records
information about all the files stored on the diskette. Chapter 3 provides a
much more detailed account of this operation. The syntax for formatting a
diskette is really quite simple:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "N0:DISK NAME,ID"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "N:DISK NAME,ID"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "N0:MY DISKETTE,MD"
                    CLOSE 15

    DOS 5.1:        >N0:DISK NAME,ID
                    >N:DISK NAME,ID

The disk command, "N0:MY DISKETTE,MD", is sent to the drive by the PRINT#15
statement. The command has three parameters. The first parameter within
quotes is N0:. The N stands for NEW. The 0 is a holdover from the dual drive
system and indicates which drive. The 0 is optional on the 1541 and may be
omitted. The colon terminates the DOS command. The second parameter is the
disk name. It is limited to 16 characters in length. Generally these are
alphanumeric characters. In the example above, we named the diskette: MY
DISKETTE. The disk name is cosmetic and appears in the directory for
reference purposes only. It is not written anywhere else on the diskette. The
disk name is followed by a comma. The DOS looks or parses for this. After the
comma are two alphanumeric characters for the disk ID. In the above example
we selected MD as our disk identifier. The ID is written to every block or
sector on the diskette. It is impossible to alter. The DOS repeatedly looks
at the ID of a sector to be sure that you have not switched diskettes on it.
Each diskette should be formatted with a unique ID. This will prevent the DOS
from inadvertently overwriting programs on what appears to be an identical
diskette.

A "full" new on a diskette takes roughly 2-3 minutes. There is a quicker way
to erase a diskette that has already been used. This is accomplished by
leaving off the disk ID. For example:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "N0:DISK NAME"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "N:DISK NAME"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "N0:TEST DISKETTE"
                    CLOSE 15

    DOS 5.1:        >NO:DISK NAME
                    >N:DISK NAME

Notice that no comma or ID follows the disk name. This command will work only
on a diskette that has previously been formatted. It is referred to as a
"short" new. A "short" new simply erases the first sector in the directory
and writes an empty BAM (block availability map) to tell the DOS that we have
a fresh diskette in use.

NOTE: A diskette that is plagued by read or write errors does not have to be
pitched. Copy the files to another diskette first. Then do a "full" new on
the offending diskette. This will erase and reformat the entire diskette. A
"short" new rewrites only sectors 0 and 1 of track 18 and will not eliminate
any read or write errors. See Chapter 8 about how to recover from both a
"short" new and a "full" new.


### The Initialize Command

Initialization has nothing to do with formatting. APPLE™ owners format a
diskette by "initializing" it. This is NOT TRUE with Commodore. Initializing
a diskette forces the DOS to read the disk ID and the contents of the BAM and
store them in the drive's internal memory. The BAM establishes where the next
available sector is for writing. Without it files would be overwritten. To
initialize a diskette perform the following:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "I0"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "I"

    DOS 5.1:        >I0
                    >I

The I is short for INITIALIZE. The drive number can be ignored if you are
using only one 1541. The drive motor purrs for a few seconds and then settles
down. It's that simple. It is a good habit to initialize a diskette each time
you insert it into your 1541 drive. This point cannot be overemphasized. Do
it yourself. Do not rely upon the "autoinit" feature of the drive.
Initialization prevents the DOS from overwriting files in the event that two
diskettes with identical IDs are swapped. The drive cannot tell the
difference between two diskettes with identical IDs since it is the ID that
the DOS uses to identify a diskette. Initialization also assures you that a
diskette is properly seated in the drive before use.

The 1541 drive has a built in autoinitialization feature. Once it encounters
an error it will retry a disk operation several times. Often it can recover
from an error on its own. If it fails, it gives up. Before doing so, though,
it will do a "bump." On a bump the read/write head is stepped outwards 45
tracks (slight overkill) to assure that it is on track 1. The drive clatters
when a protrusion on the stepper motor's drive pulley bumps up against a
mechanical stop. (It really isn't a melt down.) The head then steps inwards
to track 18 and the DOS awaits further instructions. Self initialization
avoids this scenario. Initialize every time you insert a diskette into the
drive.

Initialization clears the error channel and turns off the flashing red LED.
Unless, of course, you are trying to initialize an unformatted diskette or
forgot to put one in the drive to begin with. Clearing the error channel
destroys the error status the DOS prepared for you. If error checking is
important, retrieve the error message first; then initialize the drive.


### The Rename Command

Occasionally you will want to change the name of a file stored on a diskette.
To rename a file you first open the command channel and then send the rename
command like this:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "R0:NEW NAME=OLD NAME"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "R:NEW NAME=OLD NAME"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "R0:DISPLAY T&S=DTS"
                    CLOSE 15

    DOS 5.1:        >R0:NEW NAME=OLD NAME
                    >R:NEW NAME=OLD NAME

Again the syntax is exacting but simple to follow. The R0: means to rename on
drive 0. It is short for RENAME0:. As before, the 0 is optional on the 1541.
The next parameter is the new file name. A file name is generally
alphanumeric in nature and 16 characters are allowed at the maximum. (Commas,
colons, semicolons, and wild cards are not permitted. Cursor control and
reverse video characters should be avoided.) The new file name is followed by
an " = " sign. The last parameter is the existing or old file name. It must
be spelled out exactly as it appears in the directory. Wild cards (*,?) are
not allowed. If you make a typo on this parameter or the file does not appear
in the directory, the rename command fails. No damage is done, so relax. In
the above example our new file name is DISPLAY T&S. It replaces the old file
name DTS. One final point. You cannot rename a file that is currently open
for a read or write.


### The Copy Command

The copy command allows you to easily backup an existing file on your
diskette. There are three restrictions attached. First, the new file must
have a different name. Second, the copy command will not work on a relative
file. Third, you must have enough room on the diskette. The copy command
looks like this:

    SYNTAX:
            OPEN 15, 8, 15
            PRINT#15, "C0:BACKUP=0:ORIGINAL"
            CLOSE 15

    ALTERNATE:
            PRINT#15, "C:BACKUP=ORIGINAL"

    EXAMPLE:
            OPEN 15, 8, 15
            PRINT#15, "C0:MY PROGRAM B/U=0:MY PROGRAM"
            CLOSE 15

    DOS 5.l:
            >C0:BACKUP=0:ORIGINAL
            >C:BACKUP=ORIGINAL

The C is short for COPY. The new file above is called MY PROGRAM B/U. It is a
backup copy of a previous program called MY PROGRAM. Note that we must
specify the drive number twice. Again this is a holdover from a dual drive
configuration. The C does not appear twice, however. The same restrictions
that apply to the rename command are also in effect here, i.e., 16 character
file name limit, use of restricted characters, etc. The drive number is
optional. See the alternate syntax to save a few keystrokes.

It is also possible to merge two or more sequential data files using the copy
command. The syntax for this is as follows:

    SYNTAX:
            OPEN 15, 8, 15
            PRINT#15, "C0:COMBINED=0:FILE1,0:FILE2,0:FILE3"
            CLOSE 15

    ALTERNATE:
            PRINT#15, "C:COMBINED=FILE1,FILE2,FILE3"

    EXAMPLE:
            OPEN 15, 8, 15
            PRINT#15, "C0:MAILFILE=0:NAME,O:ADDRESS,0:CITY"
            CLOSE 15

    DOS 5.l:
            > CO:COMBINED=0:FILE1,0:FILE2,0:FILE3
            >C:COMBINED=FILE1,FILE2,FILE3

Our large file now consists of several files appended together. While this
feature of the copy command is available, it is rarely used. Few programming
techniques would require or ever utilize this feature. Note that this
technique cannot be used to append a subroutine onto a BASIC program; the
subroutine cannot be merged into the main program by the disk drive. You will
need to use a programmer's aid like POWER™, SYSRES™, or BASIC AID™ for the
C64 to do this.


### The Scratch Command

To get rid of an unwanted file, we scratch it. The only exception is an
unclosed file. An unclosed file is one that appears in the directory as
having zero blocks and whose file type is preceded by an asterisk (*SEQ,
*PRG, etc.). This will be explained below. To scratch a file, first remove
the write protect tab and key in:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "S0:FILE NAME"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "S:FILE NAME"

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:TESTING 123"
                    CLOSE 15

    DOS 5.1:        >SO:FILE NAME
                    >S:FILE NAME

The scratch command requires a single parameter, the file name, preceded by S
or SCRATCH. As before, the drive number is optional.

There are some variations that incorporate wild cards. Wild cards in a file
name are asterisks (*) or question marks (?). They should be used with utmost
caution since more than one file can be scratched at a time.

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:T*"
                    CLOSE 15

    DOS 5.1:        >S0:T*

In the above example all files beginning with the letter T, regardless of
file type, will be scratched. In the event that no file starts with the
letter T, none will be affected. Careless use of a wild card can have
catastrophic results. For example:

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:*"
                    CLOSE 15

    DOS 5.1:        >S0:*

The above command will scratch every file on the diskette. It is the
equivalent of performing a short new on a diskette. Be careful!

The second wild card is the question mark. It is used to mask out characters
that are not of importance. Suppose we want to scratch a number of files
whose names are all eight characters long and end in .C64. We could not use
.C64* to scratch them since the match falls at the end of the file name.
However, we could use:

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:????.C64"
                    CLOSE 15

    DOS 5.1:        >S0:????.C64

Note that we used four question marks in the above example. An exact match of
.C64 must occur on characters 5 through 8 of the file name. No match — no
scratch. If we had 1541.C64 and C100.C64 on the disk, both would be scratched
by the previous command. However, BACKUP.C64 would not be affected.

More than one wild card can be used within the same command. For example:

    EXAMPLE:        OPEN 15, 8, 15
                    PRINT#15, "S0:T?ST*"
                    CLOSE 15

    DOS 5.1:        >S0:T?ST*

This command would scratch files with these names: TEST, TASTY, TESTING123.
The file TOAST would not be affected. Note that it makes no sense to send a
command like this: "S0:T*ST???". The asterisk has priority over the question
mark. All characters that appear after the asterisk are ignored.

A file type that begins with a * is unclosed: *SEQ, *PRG, etc. It was never
closed properly. This can happen for a variety of reasons:

1. The diskette may have been at its physical capacity and a disk-full
   situation occurred during a save or write to a diskette.

2. A bad sector may have been encountered during a write to a diskette.

3. The file may have been left open following a write operation because you
   forgot to CLOSE the file, or you aborted the program by hitting either the
   RUN/STOP key or the RUN/STOP and the RESTORE keys.

4. Your program had a syntax error in it and the BASIC interpreter returned
   you to immediate mode.

(See Chapter 8 about how to recover an unclosed file.)

Whatever the cause, *an unclosed file should never be scratched!* Since the
write operation was aborted, the internal organization of the diskette (i.e.,
the BAM), has been left in disarray. It does not match the actual file
contents of the diskette. Any further attempt to write to that diskette will
probably cause a loss of one or more files. Files can actually overlap one
another now and you will be left with a poisoned diskette. The DOS does have
a command to decorrupt itself. This is the validate command. When in doubt,
validate your diskette!

The scratch command does not actually erase the file on your diskette. Rather
it traces the file across the surface of the diskette and frees any sectors
the file occupied. The file-type byte is also changed to a zero in the
directory which indicates to the DOS that it is no longer active. *If you
inadvertently scratch a file that you didn't mean to, stop right then and
there!* You can recover it. Do not attempt to write to the diskette. The
sectors just freed will be used on subsequent writes to the diskette. Once
you write to the diskette, recovery is impossible. Chapter 8 on Getting Out
of Trouble shows you how to recover a scratched file.


### The Validate Command

This command tells the DOS to reconstruct its map which shows where
information is stored on the diskette, so it conforms to the files listed in
the directory. This is a simple way to decorrupt a damaged diskette. However,
it is not a failsafe command as will be explained shortly. A validate command
looks like this:

    SYNTAX:         OPEN 15, 8, 15
                    PRINT#15, "V0"
                    CLOSE 15

    ALTERNATE:      PRINT#15, "V"

    DOS 5.1:        >V0
                    >V

The V is an abbreviation for VALIDATE. As before, the 0 is optional for the
1541 drive.

What does a validate do? The DOS keeps a map that indicates which sectors on
a diskette are currently in use. This map is stored on track 18, sector 0. It
is referred to as the Block Availability Map or just the BAM for short. When
the validate command is issued, all blocks are freed in the BAM on the
diskette simulating a newly formatted blank diskette. The drive then picks up
the first file in the directory and chains through the entire file. As
sectors are picked up along the way, they are allocated in the BAM as
currently in use. If the file is traced successfully, all blocks associated
with it are put back into the BAM as in use. The next file is then picked up
out of the directory and the process continues. When all files have been
traced, the new BAM is written to the diskette and the internal count now
matches the directory contents.

So far so good. Now let's see what happens to an unclosed file. When the DOS
encounters an unclosed file in the directory during a validate command, all
it does is change the file type byte in the directory entry to a 0 (scratched
file). No attempt is made to trace the file. When the validate operation is
complete, the unclosed file will no longer appear in a directory listing and
any blocks associated with it will be free. This is what you want to happen.
Now let's see what happens if you attempt to SCRATCH an unclosed file.

When you scratch a file, two things happen: the file-type byte in the
directory for this file is set to 0 (scratched file) and the DOS traces
through the chain of sectors that make up the file and marks each sector it
encounters as available for use (free) in the BAM. This is just what you want
to have happen for a normal file, but it can poison the diskette when you try
it on an unclosed file. Here's why. The last sector of an unclosed file was
never written out to the diskette. As a result, the second to the last sector
points to a sector that is not really part of the file. The DOS doesn't
realize this and continues to follow the "chain." If you are lucky, the
"unwritten sector" will be a empty sector (never used since the disk was
formatted). If this happens, the DOS will stop because pointers point to a
non-existent track and sector (75,1). If you are unlucky, the "unwritten
sector" will be part of a file that you scratched last week and the pointer
will just happen to point into the middle of that very important file you
just saved yesterday. When this happens, the DOS will merrily deallocate the
remaining sectors in your file. The next write operation to the diskette will
see this nice big open space and the new information will be saved right on
top of your active file. Now the situation has gone from bad to worse and is
in fact pathological — hence a poisoned disk. The only solution is to inspect
each file first to ensure that it is not tainted and then copy it onto
another diskette.

The validate routine is aborted if an error (an unreadable sector) is
encountered. When it aborts, nothing radical occurs. The new BAM is not
written to the disk until the validation process has been completed. Don't
worry about the blank BAM getting you in trouble; the DOS will read the old
one back in before it allows you to write to the disk. However, the diskette
still remains corrupted with no quick remedy in sight. Chapter 8 on recovery
deals with this and other disasters.

﻿
﻿
# CHAPTER 3 - DISKETTE FORMATTING

When you take a new floppy diskette out of the package, it is blank. Before
the drive can store data onto it, it must be formatted. This is done by
inserting the diskette into the drive and sending a NEW command to the DOS
(see Section 2.5). During "formatting" or "newing", 35 concentric tracks are
written to the diskette. Each track is made up of varying numbers of
sectors/blocks where programs and data will eventually be stored. In addition
to laying down empty blocks/sectors, the DOS creates a directory and a block
availability map (BAM) and records them on track 18.

This chapter describes the formatting process and the tracks and sectors of a
diskette. Chapter 4 describes the directory and the block availability map
(BAM).

## 3.1 Layout of Tracks and Sectors

During the formatting (newing) process, the DOS divides the diskette into
tracks and sectors. A track is a circular path on the diskette along which
information is stored.

Each track is concentric with the hole in the center of the diskette. There
are a total of 35 tracks numbered from 1 to 35. Track 1 is the outermost
track and track 35 is the innermost track. The read/write head may be
positioned to any given track. The position of track 1 is determined by a
mechanical stop that limits the outward movement of the read/write head. The
other tracks are identified by their distance from track 1. The diagram below
indicates the layout of the tracks on a formatted diskette.

[tracks layout diagram - currently omitted]()

[sectors layout diagram - corrently omitted]()

Although there are only 35 tracks, the stepper motor can position the
read/write head to more than 70 different positions. This might seem to imply
that additional tracks could be recorded on the surface of the diskette to
increase its storage capacity. Unfortunately, the accuracy of the head
positioning mechanism and the width of the path of magnetization produced by
the read/write head makes the use of these "phantom" tracks unreliable. If
you would like to experiment with this, the programs described in Chapter 9
allow you to experiment with stepping the head around.

Each track is divided into seventeen or more sectors (blocks). Each sector
holds 256 bytes of data. (Some manufacturers record data in 512 or 1024 byte
sectors.) Whenever data is read from or written to a diskette, it is done one
complete sector at a time.

On Commodore disk drives, the tracks are not divided into a fixed number of
sectors. The number of sectors depends on the track number. The outer tracks
(lower numbers) are longer and are divided into more sectors than the inner
(higher numbered) tracks. The table below summarizes how the diskette is
organized.

Organization of Tracks and Sectors on a 1541 Formatted Diskette

             Track      Range of Sector    Total Sectors    Total Bytes
    Zone    Numbers        Numbers           Per Track       Per Track
    ----    --------    ---------------    --------------   -----------
     1       1 to 17       0 to 20               21            5376
     2      18 to 24       0 to 18               19            4864
     3      25 to 30       0 to 17               18            4608
     4      31 to 35       0 to 16               17            4352

A total of 683 sectors are written at the time of initial formatting. Since
the disk rotates at a constant speed of 300 rpm, you may wonder how Commodore
manages to vary the number of sectors from zone to zone. This is accomplished
by varying the rate at which data is read or written (changing the clock
rate). Each of the four zones uses a different clock rate. This is
accomplished by using a high speed clock and dividing the clock by N, where
the value of N is determined by the zone. The table below summarizes the
clock rates for each zone.

    Zone    Tracks    Divisor      Clock Rate      Bits/Rotation
    ----   --------   -------   ----------------   -------------
     1      1 to 17     13      307,692 bits/sec     61,538.4
     2     18 to 24     14      285,714 bits/sec     57,142.8
     3     25 to 30     15      266,667 bits/sec     53,333.4
     4     31 to 35     16      250,000 bits/sec     50,000.0

This scheme provides a recording density that varies from about 4000
bits/inch on the outer tracks to almost 6000 bits/inch on the inner tracks.

If all of the possible bits could be used for data alone, we would be able to
store a total of 2,027,676 bits or 253,459 bytes on a diskette.
Unfortunately, not all of these bytes can be used for data. The total storage
capacity of a diskette formatted on the 1541 is 174,848 bytes. The need for
space to store a directory to keep track of the location of the files on a
diskette (see Chapter 4) further reduces us to an effective storage capacity
of 169,984 bytes (256 bytes * 664 sectors).

## 3.2 Layout of a Sector

During the formatting (newing) process, the DOS creates and records onto the
diskette all 683 sectors/blocks that will eventually be used for storing
information. Each sector is comprised of two parts:

1. A header block that identifies the sector.
2. A data block that holds the 256 bytes of data.

The diagram below illustrates how these parts are arranged.

      SECTOR #0                             SECTOR #1
    --------------------------------------------------------
    | |              | |              |#| | |              |
    | | HEADER BLOCK | |   DATA BLOCK |#| | | HEADER BLOCK | --+
    | |              | |              |#| | |              |   |
    --------------------------------------------------------   |
                                                               |
              +------------------------------------------------+
              |
              |                               SECTOR #2   |\
              |   ----------------------------------------- \
              |   | |                |#| | |                 \
              +-->| |   DATA BLOCK   |#| | | HEADER BLOCK     >
                  | |                |#| | |                 /
                  ----------------------------------------| /
                                                          |/
                 ---              ---
                 | |              |#|
                 | | = sync mark  |#| = inter-sec gap
                 | |              |#|
                 ---              ---

The sectors are recorded in numerical sequence along the circular track. Each
sector consists of an identifying header block followed by a data block. The
sectors are separated from each other by an inter-record gap. A special
character called a SYNC MARK is used to mark the beginning of each header or
data block.

A SYNC MARK is a very special character. It consists of 10 or more 1 bits in
a row (normally 40 of them). This particular pattern of bits only occurs at
the start of a header or data block. The hardware in the 1541 drive can
detect this character and signal the DOS that a new data or header block is
coming.

If you are puzzled about why several $FF characters in a row in the data
block are not interpreted as a sync character, you may want to skip ahead to
the section on Commodore's GCR encoding scheme in Chapter 7.

## 3.3 The Header Block

The header block of a sector allows the DOS to identify which track and
sector is being read. It is composed of a sync mark, eight bytes of
identifying information, and a header gap. The diagram below shows the layout
of a header block.

    ------------------------------------------------------------------\
    | SYNC |  HEADER  | HEADER BLOCK | SECTOR | TRACK  | ID CHARACTER  \
    | MARK | BLOCK ID |   CHECKSUM   | NUMBER | NUMBER |   NUMBER 2    / ---+
    -------------------------------------------------------------------\    |
                                                                            |
      +---------------------------------------------------------------------+
      |
      |   \-----------------------------------------------
      +--> \ ID CHARACTER | $0F BYTE | $0F BYTE | HEADER |
           /   NUMBER 1   |          |          |  GAP   |
           \----------------------------------------------

NOTE: The header is recorded on disk exactly as indicated above. The diagram
on page 54 of the *1541 User's Manual* is incorrect.

Let's examine the bytes that make up the header block:

* **Sync Mark:** This consists of 10 or more 1 bits as described above. It
  warns the DOS that either a data block or a header block is coming.

* **Header Block ID:** This is normally a $08 byte. It serves to indicate to
  the DOS that this is a header block and not a data block.

* **Header Block Checksum:** This is a checksum character used by the DOS to
  ensure that the header block was read correctly. It is found by EORing the
  track number, the sector number, and the two ID characters. If you are not
  sure what an EOR is, you may want to read through Section 7.1.

* **Sector Number:** This byte is the number of this particular sector. The
  sectors are numbered consecutively around a track.

* **Track Number:** This byte is the number of this particular track. The DOS
  uses this byte to check to be sure that the record/play head is positioned
  to the correct track.

* **ID Character #2:** This is the second ID character that you specified in
  the NEW command when the diskette was formatted (e.g., the 1 in
  "N0:GAMES,V1"). It is sometimes referred to as the ID HI. The DOS checks
  this byte against a master disk ID to ensure that you have not swapped
  diskettes.

* **ID Character #1:** This is the first ID character that you specified in
  the NEW command when the diskette was formatted (e.g., the V in
  "N0:GAMES,V1"). It is sometimes referred to as the ID LO. The DOS checks
  this byte against a master disk ID to ensure that you have not swapped
  diskettes.

* **$0F Bytes:** These bytes are used as padding (spacing) by the DOS during
  initial formatting. They are called "OFF" bytes. Once formatting is
  complete OFF bytes are never referenced again.

* **Header Gap:** The header gap consists of eight $55 bytes. These eight
  bytes are used to provide breathing room between the header block and the
  data block. The DOS never reads these bytes. They allow the DOS time to
  set-up for reading the data block that follows. NOTE: The 4040 drive uses a
  nine byte header gap. This is one of the reasons why 1541 drives and 4040
  drives are NOT WRITE COMPATIBLE! See Chapter 9 for more information.

NOTE: A header block is written *only* during the formatting process. It is
never rewritten again, period.

## 3.4 The Data Block

The data block of a sector stores the 256 data bytes for this sector. It is
composed of a sync mark, a data block ID character, the 256 bytes of data, a
data block checksum byte, two off bytes, and an inter-sector gap. The diagram
below depicts the layout of a data block.

    -------------------------------------------------------------------
    | SYNC | DATA  |      256       | DATA     | $00  | $00  | INTER- |
    | MARK | BLOCK |   DATA BYTES   | BLOCK    | BYTE | BYTE | SECTOR | --+
    |      | ID    |                | CHECKSUM |      |      | GAP    |   |
    -------------------------------------------------------------------   |
                                                                          |
                               +------------------------------------------+
                               |
                               |                           |\
                               |    ------------------------ \
                               |    |  SYNC |  HEADER |       \
                               +--> |  MARK |  BLOCK  |        >
                                    |       |  ID     |       /
                                    ------------------------ /
                                                           |/

Let's examine the bytes that make up the data block:

* **Sync mark:** This consists of 10 or more 1 bits as previously described.
  It warns the DOS that either a data block or a header block is coming.

* **Data Block ID:** This byte is normally a $07. It serves to indicate to
  the DOS that this is a data block and not a header block ($08).

* **256 Data Bytes:** This is the actual data stored in the sector. See
  Chapter 4 about how Commodore uses the first two bytes as a forward track
  and sector pointer instead of actual data.

* **Data Block Checksum:** This is a checksum character used by the DOS to
  ensure that the data block was read correctly. It is found by EORing all
  256 data bytes together.

* **$00 Bytes:** These two bytes are also called OFF bytes. They are used to
  pad a data block before it is written. They are not referenced again by the
  DOS.

* **Inter-sector Gap:** This is also known as the "tail gap." Its purpose is
  to provide breathing room between the end of the data block and the start
  of the next sector. The length of the gap varies from zone to zone and from
  one drive to another (see the chart in Section 7.1). Between consecutive
  sectors the gap is normally 4 to 12 bytes long. The gap between the last
  sector on a track and sector zero is often longer — up to 100 bytes in
  length. The gap is designed to be long enough so that if you write a data
  block on a day when your drive is turning slightly faster than 300 rpm, you
  won't overwrite the start of the next sector. (Your drive may not be
  turning at exactly 300 rpm all the time because of fluctuations in the
  power supplied to your home or office, mechanical wear, belt slippage,
  changes in temperature, etc.) Note that the DOS never reads these bytes.

The entire data block (including the preceding sync mark) is rewritten each
time data is recorded on a diskette.

This concludes our overview on how a diskette is formatted. Additional
details about how bytes are encoded on the surface of a diskette are provided
in Section 7.1. The actual recording process is described in Section 9.7.

﻿

# CHAPTER 4 - DISKETTE ORGANIZATION

## 4.1 Information Management

The information that is stored on a floppy disk is virtually useless unless
it can be retrieved quickly. As a result, the organization and management of
information is one of the most important tasks of the DOS. To do an efficient
job of management, the DOS must be able to:

1. Keep track of which sectors contain data and which are still empty
(available for use).

2. Assign names and storage locations to large blocks of related information
(files).

3. Keep track of the sequence of sectors that were used to store a file.

The DOS stores most of this information in the directory on track 18, halfway
between the outermost track (1) and the innermost track (35). Centering the
directory serves to minimize head movement across the diskette and extends
the life of both the drive and the media. The directory is subdivided into
two areas—the map showing which sectors are in use and which are free (the
Block Availability Map or BAM) and directory entries. The BAM resides solely
on sector 0 of track 18. It informs the drive as to what sectors are
currently in use and where subsequent writing to the diskette can safely take
place. The remaining sectors (1-18) of track 18 contain directory entries
(file names, file types, and pointers to where files are stored on the
diskette).

## 4.2 The Directory You See

Let's examine the directory of the 1541TEST/DEMO diskette that came with your
drive. Insert it in your drive and type on your keyboard:

    LOAD "$0",8

then type

    LIST

After a brief pause you should see the following on your screen:

    0 "1541TEST/DEMO   " ZX 2A
    13   "HOW TO USE"       PRG
    5    "HOW PART TWO"     PRG
    4    "VIC-20 WEDGE"     PRG
    1    "C-64 WEDGE"       PRG
    4    "DOS 5.1"          PRG
    11   "COPY/ALL"         PRG
    9    "PRINTER TEST"     PRG
    4    "DISK ADDR CHANGE" PRG
    4    "DIR"              PRG
    6    "VIEW BAM"         PRG
    4    "CHECK DISK"       PRG
    14   "DISPLAY T&S"      PRG
    9    "PERFORMANCE TEST" PRG
    5    "SEQUENTIAL FILE"  PRG
    13   "RANDOM FILE"      PRG
    558 BLOCKS FREE.

The 0 refers to which drive was accessed. This is a holdover from the 4040
dual drive system. Next you see the diskette name — 1541TEST/DEMO. In the
event that the diskette name is less than 16 characters in length, blank
spaces are appended to the end of the name. This forced spacing is known as
padding. Following the name of the diskette is the disk ID — ZX in this
instance. These two characters are generally (but not always) the unique
alphanumeric characters under which the diskette in question was formatted
originally. The diskette name and ID are cosmetic in nature and appear in the
directory for your reference purposes only. The 2A indicates the DOS version
and format, 4040 in this instance — again a holdover. Next we see the active
file entries on the diskette itself. Each directory entry has three fields:

1. The number of blocks/sectors the given file occupies.
2. The file name.
3. The file type.

Your demo diskette came with 15 active files on it. Moreover, they are all
program files denoted by PRG. The last entry in the directory is the
remaining number of available blocks/sectors left on the diskette for
storage. It is the difference between 664 blocks available at the time of
original formatting and the sum of the blocks of the active files (664 - 106
= 558).

What you see on your screen is not necessarily how the directory is stored on
your diskette, however. Let's begin our look at the directory with the Block
Availability Map (BAM).

## 4.3 The Block Availability Map (BAM)

The BAM is where the DOS keeps track of which sectors (blocks) on the
diskette contain information (are in use) and which ones can be used for
storing new information (are free). This map is stored on track 18, sector 0.
Here is a hex dump of that sector on the 1541TEST/DEMO disk so we can examine
it in detail.

                1541TEST/DEMO

             TRACK 18 - SECTOR 0

    . 00: 12 01 41 00 15 FF FF 1F ..A.....  BAM TRACK   1
    . 08: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  2-3
    . 10: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  4-5
    . 18: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  6-7
    . 20: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS  8-9
    . 28: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS 10-11
    . 30: 15 FF FF 1F 15 FF FF 1F ........  BAM TRACKS 12-13
    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
    . 40: 00 00 00 00 00 00 00 00 ........  BAM TRACKS 16-17
    . 48: 10 EC FF 07 00 00 00 00 ........  BAM TRACKS 18-19
    . 50: 00 00 00 00 12 BF FF 07 .....?..  BAM TRACKS 20-21
    . 58: 13 FF FF 07 13 FF FF 07 ........  BAM TRACKS 22-23
    . 60: 13 FF FF 07 12 FF FF 03 ........  BAM TRACKS 24-25
    . 68: 12 FF FF 03 12 FF FF 03 ........  BAM TRACKS 26-27
    . 70: 12 FF FF 03 12 FF FF 03 ........  BAM TRACKS 28-29
    . 78: 12 FF FF 03 11 FF FF 01 ........  BAM TRACKS 30-31
    . 80: 11 FF FF 01 11 FF FF 01 ........  BAM TRACKS 32-33
    . 88: 11 FF FF 01 11 FF FF 01 ........  BAM TRACKS 34-35
    . 90: 31 35 34 31 54 45 53 54 1541TEST  DISK NAME
    . 98: 2F 44 45 4D 4F A0 A0 A0 /DEMO
    . A0: A0 A0 5A 58 A0 32 41 A0   ZX 2A   DOS TYPE & DISK ID
    . A8: A0 A0 A0 00 00 00 00 00    .....  UNUSED
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

As indicated above, the BAM does not take up all 256 bytes on this sector.
There are several other things stored here as well. The table below
identifies the various parts. Note that the sector dump above uses
hexadecimal notation while the table below gives the decimal equivalents.

  Bytes  | Contents  | Purpose
:-------:|:---------:|:-----------------------------------------------
   0/1   |    18/1   | Pointer to first sector of directory entries
    2    |     65    | ASCII character A indicating 1541/4040 format
    3    |     0     | Unused
  4-143  |           | Block Availability Map (BAM)
 144-159 |           | Diskette name padded with shifted spaces
 160-161 |    160    | Shifted spaces
 162-163 |           | Diskette ID
   164   |    160    | Shifted space
 165-166 |   50/65   | DOS version and format type (2A)
 167-170 |    160    | Shifted spaces
 170-255 |     ?     | Unused

In the BAM four bytes are used to describe the status of each track. As a
result, the BAM takes up a total of 4 x 35 = 140 bytes (bytes 4-143 or
$04-$8F). Let's examine the entry for track 14 to see what these four bytes
mean. The entry for track 14 begins at byte 14 x 4 = 56 ($38). It looks like
this:


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          ** ** ** **

The first byte for track 14 (location $38 = 56) indicates the number of
blocks free on this track.


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          **

In this case there are $11 or 17 (1 * 16 + 1) blocks free.

When the DOS calculates the number of blocks free on a diskette, it sums this
byte from each track's entry in the BAM. Let's do our own blocks free
calculation to see how it is done. All we have to do is sum up the decimal
values of every fourth byte starting with byte 4 like this:

                              HEX    DECIMAL
     ZONE    BYTE    TRACK   VALUE    VALUE
    ------  ------  ------- ------- ---------
      1        4       1      $1F       21
               8       2      $1F       21
              12       3      $1F       21
              16       4      $1F       21
              20       5      $1F       21
              24       6      $1F       21
              28       7      $1F       21
              32       8      $1F       21
              36       9      $1F       21
              40      10      $1F       21
              44      11      $1F       21
              48      12      $1F       21
              52      13      $1F       21
              56      14      $11       17
              60      15      $00        0
              64      16      $00        0
              68      17      $00        0

    2         72      18      $10       16
              76      19      $13       19
              80      20      $13       19
              84      21      $13       19
              88      22      $13       19
              92      23      $13       19
              96      24      $13       19

    3        100      25      $12       18
             104      26      $12       18
             108      27      $12       18
             112      28      $12       18
             116      29      $12       18
             120      30      $12       18

    4        124      31      $11       17
             128      32      $11       17
             132      33      $11       17
             136      34      $11       17
             140      35      $11     + 17
                                    ---------
                                       574      BLOCKS FREE

Wait a minute! We calculated 574 blocks free but the directory shows 558. How
do we explain this discrepancy? Easy. Remember that the DOS reserves track 18
for its own use. Therefore the blocks free on that particular track are not
returned to us (574 - 16 = 558). Sixteen sectors on track 18 are still free,
but available only to the DOS.

Now that you have seen how to calculate the number of blocks free on a
diskette, let's get back to our analysis of track 14. The BAM entry looked
like this:


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          ** ** ** **

The first byte was easy to interpret. The remaining three bytes are a bit
trickier (no pun intended). They are a bit map showing the status of the
sectors on a given track. Bit mapping is used to save space. If one byte were
used for each of the 683 sectors, the BAM would take up three sectors (683 /
256). This would be inefficient. By using bit mapping, each byte describes
the status of eight sectors. This way only three bytes are needed for each
track. Let's examine the bit map for track 14 of our 1541 TEST/DEMO.


    . 38: 11 D7 5F 1F 00 00 00 00 .W......  BAM TRACKS 14-15
          ** ** ** **

     LOCATION       $39=57          $3A=58          $3B=59
    BYTE VALUE       $D7             $5F             $1F
      BINARY       11010111        01011111        00011111 *

      SECTOR                       111111             21111
      NUMBER       76543210        54321098        xxx09876

                 * 1 = FREE
                   O = ALLOCATED

Sectors 0 to 7 are represented by the byte at location 57. Sectors 8 through
15 are stored in the byte at location 58. Finally, sectors 16 through 20 are
depicted by the byte at location 59. When decoded, a bit that is high or a 1
indicates that a sector is not currently in use (free) and can be written to.
A bit that is low or a 0 is currently in use (allocated) and will be
overlooked by the DOS when writing subsequently takes place to the diskette.
The third byte is always incomplete since a maximum of 21 sectors are written
to any track. This particular byte is automatically adjusted by the DOS
during initial formatting to indicate the proper number of sectors for this
track. Three bytes are still used irregardless of the zone, however. If you
count up the 1s in the bit map for track 14, you will find that there are 17
free sectors on track 14. This agrees with the blocks free count for the
track stored at byte location $38 (56) in the BAM, i.e., $11 or 17 decimal.

To ensure that you understand how the bit mapping works, let's take a look at
track 18. Since track 18 is used for storing the directory we would expect
some allocation of sectors here. Byte 72 shows $10 or 16 sectors available
here. They are bit mapped in bytes 73, 74, and 75 as follows:


    . 48: 10 EC FF 07 00 00 00 00 ........  BAM TRACKS 18-19
          ** ** ** **

     LOCATION       $49=73          $4A=74          $4B=75
    BYTE VALUE       $EC             $FF             $07
      BINARY       11101100        11111111        00000111 *

      SECTOR                       111111             21111
      NUMBER       76543210        54321098        xxx09876

                 * 1 = FREE
                   O = ALLOCATED

If you are still unsure of yourself, don't be too concerned. The DOS looks
after the BAM. Let's move on and explore the actual directory entries
themselves. Sectors 1 through 18 on track 18 are reserved specifically for
them.

## 4.4 The Directory Entries

Recall that bytes 0 and 1 of track 18, sector 0 point to the next track and
sector of the directory. In this particular instance, the BAM points to track
18, sector 1. Let's examine this sector in detail.

                1541TEST/DEMO

             TRACK 18 - SECTOR 01

    . 00: 12 04 82 11 00 48 4F 57 .....HOW  FILE ENTRY #1
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
    . 20: 00 00 82 11 03 48 4F 57 .....HOW  FILE ENTRY #2
    . 28: 20 50 41 52 54 20 54 57  PART TW
    . 30: 4F A0 A0 A0 A0 00 00 00 O    ...
    . 38: 00 00 00 00 00 00 05 00 ........
    . 40: 00 00 82 11 09 56 49 43 .....VIC  FILE ENTRY #3
    . 48: 2D 32 30 20 57 45 44 47 -20 WEDG
    . 50: 45 A0 A0 A0 A0 00 00 00 E    ...
    . 58: 00 00 00 00 00 00 04 00 ........
    . 60: 00 00 82 13 00 46 2D 36 .....C-6  FILE ENTRY #4
    . 68: 34 20 57 45 44 47 45 A0 4 WEDGE
    . 70: A0 A0 A0 A0 A0 00 00 00      ...
    . 78: 00 00 00 00 00 00 01 00 ........
    . 80: 00 00 82 13 01 44 4F 53 .....DOS  FILE ENTRY #5
    . 88: 20 35 2E 31 A0 A0 A0 A0  5.1
    . 90: A0 A0 A0 A0 A0 00 00 00      ...
    . 98: 00 00 00 00 00 00 04 00 ........
    . A0: 00 00 82 13 03 43 4F 50 .....COP  FILE ENTRY #6
    . A8: 59 2F 41 4C 4C A0 A0 A0 Y/ALL
    . B0: A0 A0 A0 A0 A0 00 00 00      ...
    . B8: 00 00 00 00 00 00 0B 00 ........
    . C0: 00 00 82 13 09 50 52 49 .....PRI  FILE ENTRY #7
    . C8: 4E 54 45 52 20 54 45 53 NTER TES
    . D0: 54 A0 A0 A0 A0 00 00 00 T    ...
    . D8: 00 00 00 00 00 00 09 00 ........
    . E0: 00 00 82 10 00 44 49 53 .....DIS  FILE ENTRY #8
    . E8: 4B 20 41 44 44 52 20 43 K ADDR C
    . F0: 48 41 4E 47 45 00 00 00 HANGE...
    . F8: 00 00 00 00 00 00 04 00 ........


The contents of any directory sector can be tabled as follows:

Byte    | Contents | Purpose
:------:|:--------:|:-------------------------------------
     0  |          | Track of the next directory block
     1  |          | Sector of the next directory block
        |          |
  2-31  |          | File entry #1 in the directory block
        |          |
 32-33  |    0     | Unused
 34-63  |          | File entry #2 in the directory block
        |          |
 64-65  |    0     | Unused
 66-95  |          | File entry #3 in the directory block
        |          |
 96-97  |    0     | Unused
 98-127 |          | File entry #4 in the directory block
128-129 |    0     | Unused
130-159 |          | File entry #5 in the directory block
        |          |
160-161 |    0     | Unused
162-191 |          | File entry #6 in the directory block
        |          |
192-193 |    0     | Unused
194-223 |          | File entry #7 in the directory block
        |          |
224-225 |    0     | Unused
226-255 |          | File entry #8 in the directory block

Eight file entries are recorded per sector. Let's examine the contents of a
single directory file entry.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
          ** **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........

Because this is the first entry in the directory, bytes 0 and 1 are
significant. They point to track 18, sector 4 (converts to 18). This
indicates that there are further directory entries. You will note that the
sectors are not sequential in nature, i.e., sector 1 does not point to sector
2, etc. Remember that the diskette itself is rotating at 300 rpm. Staggering
the use of the sectors allows quicker access and fewer rotations of the drive
mechanism and the media. Typically sectors are staggered in increments of 10.
The directory track is staggered in increments of 3, however. The table below
indicates the sequence in which a full directory containing 144 files is
stored:

        SECTOR FILLING SEQUENCE
           FOR THE DIRECTORY

             0 (BAM)
             1, 4, 7, 10, 13, 16
             2, 5, 8, 11, 14, 17
             3, 6, 9, 12, 15, 18


When a diskette is initially formatted, sector 1 is set up with 8 null
entries. As you store files on the diskette the directory grows. It soon
becomes a long chain of directory sectors. The first two bytes in a sector
point to the next directory sector in the chain (this is known as a forward
pointer). But, what about the last sector in the chain? It has nothing to
point to! In the last sector in the chain, there is no forward pointer; byte
0 contains a 0 ($00) and byte 1 contains a 255 ($FF) as indicated below. This
indicates to the DOS that there are no more sectors in the directory.

    . 00: 00 FF xx xx xx xx xx xx ........

One final note about chaining. Commodore uses only forward pointers. A sector
does not show where it came from, only where it is going. This makes recovery
of corrupted files much more difficult, but more about that later.

Back to our example:

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
                **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........

The first byte in the file entry is the file-type byte. In this instance we
see an $82. This is interpreted by the DOS to mean that the file entry is a
program. The following table outlines Commodores file types.

HEX   |  ASCII  | FILE TYPE                | DIRECTORY SHOWS
:----:| -------:|:------------------------ |:----------------
      |         |                          |
$00   |    0    | Scratched                | Does not appear
      |         |                          |
$80   |  128    | Deleted                  | DEL
$81   |  129    | Sequential               | SEQ
$82   |  130    | Program                  | PRG
$83   |  131    | User                     | USR
$84   |  132    | Relative                 | REL
      |         |                          |
$00   |    0    | Unclosed deleted         | Same as scratched
$01   |    1    | Unclosed sequential      | *SEQ
$02   |    2    | Unclosed program         | *PRG
$03   |    3    | Unclosed user            | *USR
$04   |    4    | Unclosed relative        | Cannot occur
      |         |                          |
$A0   |  160    | Deleted @ replacement    | DEL
$A1   |  161    | Sequential @ replacement | SEQ
$A2   |  162    | Program @ replacement    | PRG
$A3   |  163    | User @ replacement       | USR
$A4   |  164    | Relative @ replacement   | Cannot occur
      |         |                          |
$C0   |  192    | Locked deleted           | DEL<
$C1   |  193    | Locked sequential        | SEQ<
$C2   |  194    | Locked program           | PRG<
$C3   |  195    | Locked user              | USR<
$C4   |  196    | Locked relative          | REL<

Note: It is possible to edit the file-type byte and get very unusual file
types appearing in the directory (SR?< is one possibility). However, these
file types have no practical use.

Enough esoterica for now. Let's get back to our example:

The next two bytes in the file entry are a pointer to where the first sector
of that particular file is stored on the diskette.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
                   ** **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........

This file starts on track 17 ($11), sector 0 ($00).

Next we have the file name.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
                         ** ** **
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
          ** ** ** ** ** ** ** **
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
          ** ** ** ** **
    . 18: 00 00 00 00 00 00 0D 00 ........

In this case our file is named "HOW TO USE". Note that file names are padded
out to 16 characters with shifted spaces ($A0) just like the diskette name.
The shifted spaces do not show as part of the file name, however, when the
directory is displayed.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
                         ** ** **
    . 18: 00 00 00 00 00 00 0D 00 ........

The next three bytes are unused except for relative file entries. For a
relative file bytes $15 (21) and $16 (22) point to the first set of side
sectors. Byte $17 (23) gives the record size with which the relative file was
created. This special file type will be examined in detail later.

The next four bytes are always unused and therefore null ($00).

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
          ** ** ** **

The following two bytes are reserved for use by the DOS during the save and
replace operation (@ replacement). Their function can only be viewed by
interrupting the drive during a SAVE "@0:file name",8 routine. This is not
recommended for obvious reasons. (During an @ replacement the file-type byte
is ORed with $20 first. A new copy of the file is then written to the disk.
Bytes 28 ($1C) and 29 ($1D) contain the track and sector pointer to the start
of the new replacement file. At the end of the @ operation the sectors that
held the old file are marked as free in the BAM. The new track and sector
pointer is then moved from bytes 28 and 29 to bytes 3 ($03) and 4 ($04)
respectively and bytes 28 and 29 are zeroed again. The proper file type is
then restored at byte 2. See Chapter 9 about the bug in the @ replacement
command.)

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
                      ** **

The final two bytes in a file entry are the number of blocks it occupies on
the diskette. It is the sum of the leftmost byte (lo-byte) + the rightmost
byte (hi-byte) * 256.

    . 00: 12 04 82 11 00 48 4F 57 .....HOW
    . 08: 20 54 4F 20 55 53 45 A0  TO USE
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 0D 00 ........
                            ** **
                            LO HI

In our example, the file is (13 + 0 * 256) = 13 blocks long.

To be sure you understand the file entries work let's break out the first
sector of the test/demo directory to show each file entry. Remember that
bytes 0 and 1 of each entry are unused with the exception of the first entry.
Here they represent a forward track and sector chain and have nothing to do
with that file in particular.


                1541TEST/DEMO

             TRACK 18 - SECTOR 01

              DIRECTORY ENTRY 1

    . 00: 12 04 82 11 00 48 4F 57 .....HOW  File type = $82 = PRG
    . 08: 20 54 4F 20 55 53 45 A0  TO USE   Starts on 17/1 ($11/$00)
    . 10: A0 A0 A0 A0 A0 00 00 00      ...  Name: HOW TO USE
    . 18: 00 00 00 00 00 00 0D 00 ........  File length: 13 BLOCKS

              DIRECTORY ENTRY 2

    . 20: 00 00 82 11 03 48 4F 57 .....HOW  File type = $82 = PRG
    . 28: 20 50 41 52 54 20 54 57  PART TW  Starts on 17/3 ($11/$03)
    . 30: 4F A0 A0 A0 A0 00 00 00 O    ...  Name: HOW PART TWO
    . 38: 00 00 00 00 00 00 05 00 ........  File length: 5 BLOCKS

              DIRECTORY ENTRY 3

    . 40: 00 00 82 11 09 56 49 43 .....VIC  File type = $82 = PRG
    . 48: 2D 32 30 20 57 45 44 47 -20 WEDG  Starts on 17/9 ($11/09)
    . 50: 45 A0 A0 A0 A0 00 00 00 E    ...  Name: VIC-20 WEDGE
    . 58: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

              DIRECTORY ENTRY 4

    . 60: 00 00 82 13 00 46 2D 36 .....C-6  File type = $82 = PRG
    . 68: 34 20 57 45 44 47 45 A0 4 WEDGE   Starts on 19/0 ($13/$00)
    . 70: A0 A0 A0 A0 A0 00 00 00      ...  Name C-64 WEDGE
    . 78: 00 00 00 00 00 00 01 00 ........  File length: 1 BLOCK

              DIRECTORY ENTRY 5

    . 80: 00 00 82 13 01 44 4F 53 .....DOS  File type = $82 = PRG
    . 88: 20 35 2E 31 A0 A0 A0 A0  5.1      Starts on 19/1 ($13/$01)
    . 90: A0 A0 A0 A0 A0 00 00 00      ...  Name: DOS 5.1
    . 98: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

              DIRECTORY ENTRY 6

    . A0: 00 00 82 13 03 43 4F 50 .....COP  File type = $82 = PRG
    . A8: 59 2F 41 4C 4C A0 A0 A0 Y/ALL     Starts on 19/3 ($13/03)
    . B0: A0 A0 A0 A0 A0 00 00 00      ...  Name: COPY/ALL
    . B8: 00 00 00 00 00 00 0B 00 ........  File length: 11 BLOCKS

              DIRECTORY ENTRY 7

    . C0: 00 00 82 13 09 50 52 49 .....PRI  File type = $82 = PRG
    . C8: 4E 54 45 52 20 54 45 53 NTER TES  Starts on 19/9 ($13/09)
    . D0: 54 A0 A0 A0 A0 00 00 00 T    ...  Name: PRINTER TEST
    . D8: 00 00 00 00 00 00 09 00 ........  File length: 9 BLOCKS

              DIRECTORY ENTRY 8

    . E0: 00 00 82 10 00 44 49 53 .....DIS  File type = $82 = PRG
    . E8: 4B 20 41 44 44 52 20 43 K ADDR C  Starts on 16/0 ($10/00)
    . F0: 48 41 4E 47 45 00 00 00 HANGE...  Name:DISK ADDR CHANGE
    . F8: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS


We will end our tour of the directory by displaying the next sector (track
18, sector 4) which happens to end the directory chain ($00, $FF in bytes 0
and 1, respectively). Notice that only seven directory entries are present in
this block. The last directory entry is a null entry. It will be converted
into a valid entry when the directory is expanded.


                1541TEST/DEMO

             TRACK 18 - SECTOR 04

    . 00: 00 FF 82 10 01 44 49 52 .....DIR  File type = $82 = PRG
    . 08: A0 A0 A0 A0 A0 A0 A0 A0           Starts on 16/1 ($10/01)
    . 10: A0 A0 A0 A0 A0 00 00 00      ...  Name: DIR
    . 18: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

    . 20: 00 00 82 10 03 56 49 45 .....VIE  File type = $82 = PRG
    . 28: 57 20 42 41 4D A0 A0 A0 W BAM     Starts on 16/3 ($10/03)
    . 30: A0 A0 A0 A0 A0 00 00 00      ...  Name:VIEW BAM
    . 38: 00 00 00 00 00 00 06 00 ........  File length: 6 BLOCKS

    . 40: 00 00 82 10 07 43 48 45 .....CHE  File type = $82 = PRG
    . 48: 43 4B 20 44 49 53 4B A0 CK DISK   Starts on 16/7 ($10/07)
    . 50: A0 A0 A0 A0 A0 00 00 00      ...  Name: CHECK DISK
    . 58: 00 00 00 00 00 00 04 00 ........  File length: 4 BLOCKS

    . 60: 00 00 82 10 0F 44 49 53 .....DIS  File type = $82 = PRG
    . 68: 50 4C 41 59 20 54 26 53 PLAY T&S  Starts on 16/15 ($10/$0F)
    . 70: A0 A0 A0 A0 A0 00 00 00      ...  Name: DISPLAY T&S
    . 78: 00 00 00 00 00 00 0E 00 ........  File length: 14 BLOCKS

    . 80: 00 00 82 14 02 50 45 52 .....PER  File type = $82 = PRG
    . 88: 46 4F 52 4D 41 4E 43 45 FORMANCE  Starts on 20/2 ($14/$02)
    . 90: 20 54 45 53 54 00 00 00  TEST...  Name: PERFORMANCE TEST
    . 98: 00 00 00 00 00 00 09 00 ........  File length: 9 BLOCKS

    . A0: 00 00 82 14 07 50 45 52 .....SEQ  File type = $82 = PRG
    . A8: 55 45 4E 54 49 41 4C 20 UENTIAL   Starts on 20/7 ($14/$07)
    . B0: 46 49 4C 45 A0 00 00 00 FILE ...  Name: SEQUENTIAL FILE
    . B8: 00 00 00 00 00 00 05 00 ........  File length: 5 BLOCKS

    . C0: 00 00 82 0F 01 52 41 4E .....RAN  File type = $82 = PRG
    . C8: 44 4F 4D 20 46 49 4C 45 DOM FILE  Starts on 15/1 ($0F/$01)
    . D0: A0 A0 A0 A0 A0 00 00 00      ...  Name: RANDOM FILE
    . D8: 00 00 00 00 00 00 0D 00 ........  File length: 13 BLOCKS

    . EO: 00 00 00 00 00 00 00 00 ........  NULL ENTRY
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........


You will find four of the utilities listed in Appendix C particularly helpful
in furthering your understanding of the organization of a diskette. The first
program is DISPLAY TRACK & SECTOR. The hex dumps in this section were
generated using this utility. A hex dump can be sent either to the screen or
printer. When sent to the screen only half a page of the specified track and
sector is displayed at one time to prevent scrolling. Bytes 0 - 127 ($00 -
$7F) are displayed first followed by bytes 128 - 255 ($80 - $FF). Use this
program for your own experimentation. The second program is DISPLAY A BLOCK
AVAILABILITY MAP. It portrays the BAM in a two-dimensional representation.
The diskette name, ID, DOS version, and blocks free are also displayed. The
third program is VIRTUAL DIRECTORY. It displays a directory in its entirety
including scratched files. Output can be directed to a printer by changing
the OPEN 4,3 statement in line 440 to OPEN 4,4. The last program, DISPLAY A
CHAIN, traces a file chain. The chain of sectors may be viewed on the screen
or sent to the printer.

The programming techniques that are used in these sample programs will be
partially explained in later sections.

Now that we've seen how the directory is kept, let's look at how the
different types of files are actually stored on a diskette. We'll start by
looking at a program file.


## 4.5 Program File Storage

The most common type of file is a program file, PRG. It is designated by an
$82 in the directory. Program file structure is quite simple.
Diagrammatically, the first sector (block) in a program file looks like this.

    +-------+--------+------+------+---------------------------------+
    | TRACK | SECTOR | LOAD | LOAD |       THE FIRST 252 BYTES       |
    | LINK  | LINK   |  LO  |  HI  |         OF YOUR PROGRAM         |
    +-------+--------+------+------+---------------------------------+


  Byte  | Purpose
:------:|:-------------------------------------------------------------------
        |
   0    | Track of the next block in this file
   1    | Sector of the next block in this file
   2    | Lo-byte of the load address
   3    | Hi-byte of the load address
        |
 4-255  | The first 252 bytes of the program


The first pair of bytes are the pointer to the track and sector of the next
block in the file. Technically, this is known as a "forward pointer." It
points ahead to the next sector in the file. All Commodore files use this
type of pointer.

The second pair of bytes is the "load address" of the file in lo-byte/hi-byte
form. They indicate where the program is to be loaded into memory. A BASIC
program that was saved from a C64 will have a $01 and a $08 in these two
locations. This indicates that the program is to be loaded into memory
starting at memory location $0801 (remember it is in lo-byte/hi-byte form).
In decimal notation this is memory location 2049 — the start of BASIC on a
C64.

Have you ever wondered about the significance of the ",1" in the command LOAD
"name",8,1? It determines whether or not a program is "relocated" when it is
loaded into memory. If you do not specify the ",1", the C64 will ignore the
load address at the start of the file and load the program starting at memory
location $0801 (2049). When the ",1" is present, the C64 (or VIC-20) will pay
attention to the load address and load the program into memory starting at
the location specified by bytes $02 and $03.

The remaining sectors, except the last one, look like this:

    +-------+--------+------------------------------------+
    | TRACK | SECTOR |         THE NEXT 254 BYTES         |
    | LINK  | LINK   |          OF YOUR PROGRAM           |
    +-------+--------+------------------------------------+


  Byte | Purpose
:-----:|:--------------------------------------------------------------------
       |
   0   | Track of the next block in this file
   1   | Sector of the next block in this file
       |
 2-255 | The next 254 bytes of the program


The last block in a program file is special because:

1. It is the last sector.
2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00.
The first byte is normally the track link. Since there is no track 0, the DOS
knows that this is the last sector in the file. The second byte indicates the
position of the last byte that is part of the program file. Any bytes beyond
this position are garbage.

Diagrammatically, the last sector in a program file looks like this:

    +------+------+-----------------------------+---------+
    | NULL | LAST |       THE FINAL BYTES       | GARBAGE |
    | $00  | BYTE |       OF YOUR PROGRAM       |         |
    +------+------+-----------------------------+---------+


   Byte   | Purpose
:--------:|:-----------------------------------------------------------------
          |
    0     | Null byte to indicate that this is the last sector
    1     | Number of bytes to read from this sector (N)
          |
   2-N    | The last (N-2) bytes of the program
(N+1)-255 | Garbage


Let's examine the program file "DIR" on your 1541TEST/DEMO disk. DIR appears
in the directory on track 18, sector 04. The directory entry looks like this:

             TRACK 18 - SECTOR 04

    . 00: 00 FF 82 10 01 44 49 52 .....DIR
    . 08: A0 A0 A0 A0 A0 A0 A0 A0
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 04 00 ........

From the entry we see that "DIR" starts at track 16 ($10), sector 01 ($01)
and that the file is four blocks long (4 + 0 * 256).

    . 00: 00 FF 82 10 01 44 49 52 .....DIR
                   ** **
    . 08: A0 A0 A0 A0 A0 A0 A0 A0
    . 10: A0 A0 A0 A0 A0 00 00 00      ...
    . 18: 00 00 00 00 00 00 04 00 ........
                            ** **

Let's look at the first block in this file.

             TRACK 16 - SECTOR 01

    . 00: 10 0B 01 04 0D 04 04 00 ........
    . 08: 9F 32 2C 38 2C 31 35 00 .2,8,15.
    . 10: 1E 04 05 00 99 22 93 22 ....."."
    . 18: 3A 89 20 31 30 30 30 30 :. 10000
    . 20: 00 2E 04 0A 00 9F 31 2C ......1,
    . 28: 38 2C 30 2C 22 24 30 22 8,0,"$0"
    . 30: 00 3C 04 14 00 A1 23 31 .<....#1
    . 38: 2C 41 24 2C 42 24 00 4A ,A$,B$.J
    . 40: 04 1E 00 A1 23 31 2C 41 ....#1,A
    . 48: 24 2C 42 24 00 58 04 28 $,B$.X.(
    . 50: 00 A1 23 31 2C 41 24 2C ..#1,A$,
    . 58: 42 24 00 60 04 32 00 43 B$...2.C
    . 60: B2 30 00 77 04 3C 00 8B .0...<..
    . 68: 20 41 24 B3 B1 22 22 20  A$..""
    . 70: A7 20 43 B2 C6 28 41 24 . C..(A$
    . 78: 29 00 94 04 46 00 8B 20 )...F..
    . 80: 42 24 B3 B1 22 22 20 A7 B$.."" .
    . 88: 20 43 B2 43 AA C6 28 42  C.C..(B
    . 90: 24 29 AC 32 35 36 00 AF $).256..
    . 98: 04 50 00 99 22 12 22 CA .P..".".
    . A0: 28 C4 28 43 29 2C 32 29 (.(C),2)
    . A8: 3B A3 33 29 3B 22 92 22 ;.3);"."
    . B0: 3B 00 C9 04 5A 00 A1 23 ;...Z..#
    . B8: 31 2C 42 24 3A 8B 20 53 1,B$:. S
    . C0: 54 B3 B1 30 20 A7 20 31 T..0 . 1
    . C8: 30 30 30 00 DE 04 64 00 000.....
    . D0: 8B 20 42 24 B3 B1 C7 28 . B$...(
    . D8: 33 34 29 20 A7 20 39 30 34) . 90
    . E0: 00 00 05 6E 00 A1 23 31 ......#1
    . E8: 2C 42 24 3A 8B 20 42 24 ,B$:. B$
    . F0: B3 B1 C7 28 33 34 29 A7 ...(34).
    . F8: 20 99 42 24 3B 3A 89 31  .B$;:.1

Not very recognizable is it? Remember this is C64 internal BASIC not a BASIC
listing. Bytes 0 and 1 are of interest. They are the track and sector link
that point to the next block in the program file. In this case, they point to
track 16 ($10), sector 11 ($0B). Since this is the first data block of the
file, bytes 2 and 3 are also important. They are the load address. We can see
that the load address is $0401 or 1025 decimal. This file was written on a
PET. (The start of BASIC memory on the C64 is at $0801. The VIC-20 begins at
$1001, $1201, or $0401 depending on the amount of external memory.) DIR will
require a straight relocating load, i.e., LOAD "DIR",8. If you used a LOAD
"DIR", 8,1 command, the program would be loaded into the screen RAM of the
C64. NOTE: If you load this program properly, you will NOT be able to get it
to VERIFY correctly. The reason is that the internal BASIC links were changed
when the program was relocated.


    . 00: 10 0B 01 04 0D 04 04 00 ........
          ** ** ** **

Let's follow the forward chain to track 16, sector 11 and take a look at the
start of the second block in our file.


             TRACK 16 - SECTOR 11

    . 00: 10 02 31 30 00 1C 05 78 ..10....
    . 08: 00 A1 23 31 2C 42 24 3A ..#1,B$:
    . 10: 8B 20 42 24 B2 C7 28 33 . B$..(3

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nothing much of interest here. Let's chain to track 16 ($10), sector 02 ($02)
and take a look at the start of the next block.


             TRACK 16 - SECTOR 02

    . 00: 10 0C B2 22 22 3A 99 22 ..."":."
    . 08: 3E 22 3B 00 1A 06 AB 0F >";.....
    . 10: A1 42 24 3A 8B 42 24 B2 .B$:.B$.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Again, nothing much of interest. Chain to track 16 ($10), sector 12 ($0C).


             TRACK 16 - SECTOR 12

    . 00: 00 68 8B 20 41 24 B2 22 ... A$."
    . 08: 44 22 20 A7 20 31 30 00 D" . 10.
    . 10: 2D 07 3C 28 8B 20 41 24 -.<(. A$
    . 18: B2 22 2E 22 20 B0 20 41 ."." . A
    . 20: 24 B2 22 3E 22 20 B0 20 *.">" .
    . 28: 41 24 B2 22 3E 22 20 A7 A$.">" .
    . 30: 20 34 30 30 30 00 3E 07  4000.>.
    . 38: 46 28 8B 20 41 24 B2 22 F(. A$."
    . 40: 51 22 20 A7 20 80 00 52 Q" . ..R
    . 48: 07 50 28 8B 20 41 24 B2 .P(. A$.
    . 50: 22 53 22 20 A7 20 35 30 "S" . 50
    . 58: 30 30 00 5E 07 F7 2A 89 00. ..*.
    . 60: 20 31 30 31 30 30 00 00  10100..
    . 68: 00 A0 00 A1 20 54 24 3A .... T$:
    . 70: 8B 20 54 24 B3 B1 22 22 . T$..""
    . 78: 20 A7 20 8D 20 32 30 30  . . 200

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we're cooking. This is the last sector of the file. How can we tell? The
track of the next block in the file is 0 ($00). But what about the sector
link? It's a misnomer. The sector link in the last block is actually a byte
count. It informs the DOS that only bytes 2 through 104 ($68) are important
in this example. Recall that an end of file in BASIC is designated by three
zeros in a row. An End-or-Identify (EOI) signal will be sent once byte 104
has been transferred across the serial bus. When the C64 receives this EOI
signal, the status variable, ST, will be set to a value of 64. (Any further
attempt to read a byte will cause the drive to time out.) Here's the tail end
of our program. The three null bytes, ($00), at $66/7/8 are the last three
bytes in our program file.

    . 00: 00 68 8B 20 41 24 B2 22 ... A$."
    . 08: 44 22 20 A7 20 31 30 00 D" . 10.
    . 10: 2D 07 3C 28 8B 20 41 24 -.<(. A$
    . 18: B2 22 2E 22 20 B0 20 41 ."." . A
    . 20: 24 B2 22 3E 22 20 B0 20 *.">" .
    . 28: 41 24 B2 22 3E 22 20 A7 A$.">" .
    . 30: 20 34 30 30 30 00 3E 07  4000.>.
    . 38: 46 28 8B 20 41 24 B2 22 F(. A$."
    . 40: 51 22 20 A7 20 80 00 52 Q" . ..R
    . 48: 07 50 28 8B 20 41 24 B2 .P(. A$.
    . 50: 22 53 22 20 A7 20 35 30 "S" . 50
    . 58: 30 30 00 5E 07 F7 2A 89 00. ..*.
    . 60: 20 31 30 31 30 30 00 00  10100..
    . 68: xx xx xx xx xx xx xx xx .

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What about the rest of the block? Ignore it. It is garbage. The DOS does not
zero out a buffer before it begins filling it with new information sent from
the computer. As a result, the last block in a file, which is almost never
filled with new information, is padded with whatever happened to be left in
the buffer from a previous read or write operation. There are two exceptions
to the rule, namely, the directory and relative files. A partial directory
block is always padded with nulls ($00). Moreover, it always appears as a
full block. Bytes 0 and 1 of the last directory block will contain a $00 and
a $FF, respectively. Relative file structure will be explained shortly.


## 4.6 Sequential File Storage

The format of a sequential file is very straightforward. All the sectors,
except the last one, look like this:

    +-------+--------+-------------------+
    | TRACK | SECTOR | 254 BYTES OF DATA |
    | LINK  | LINK   |                   |
    +-------+--------+-------------------+


Byte     | Purpose
:------- |:------------------------------------------------------------------
         |
0        | Track of the next block in this file
1        | Sector of the next block in this file
         |
2-255    | 254 bytes of data


The last block in a sequential file is special for two reasons:

1. It is the last sector.
2. It is usually only partially full.

To signal the DOS that this is the last block, the first byte is set to $00.
The first byte is normally the track link. Since there is no track 0, the DOS
knows that this is the last sector in the file. The second byte indicates the
position of the last byte in the file. Any bytes beyond this position are
garbage.

Diagrammatically, the last sector in the file looks like this:

    +------+------+---------------------------------+---------+
    | NULL | LAST |     THE FINAL DATA BYTES IN     | GARBAGE |
    | $00  | BYTE |       YOUR SEQUENTIAL FILE      |         |
    +------+------+---------------------------------+---------+


Byte      | Purpose
:-------- |:-----------------------------------------------------------------
          |
0         | Null byte to indicate this is the last sector
1         | Position of the last byte in the file (N)
          |
2-N       | The last N-2 bytes of the sequential file
(N+1)-255 | Garbage


No sequential files appear on the 1541TEST/DEMO. (The file named SEQUENTIAL
FILE is a program file demonstrating the sequential access method.) The C-64
DISK BONUS PACK does come with one sequential file on it. The file named `"
  DIRECTORY   "` appears as a SEQ when displaying the directory.
`"   DIRECTORY   "` can be found at track 18, sector 01 on the C-64 DISK
BONUS PACK. Let's take a peek at the directory entry for this file:

             TRACK 18 - SECTOR 01

    . 20: 00 00 81 11 01 20 20 20 .....
    . 28: 44 49 52 45 43 54 4F 52 DIRECTOR
    . 30: 59 20 20 20 A0 00 00 00 Y    ...
    . 38: 00 00 00 00 00 00 02 00 ........

`"   DIRECTORY   "` is the second file entry in the directory.

    . 20: 00 00 81 11 01 20 20 20 .....
                ** ** **
    . 28: 44 49 52 45 43 54 4F 52 DIRECTOR
    . 30: 59 20 20 20 A0 00 00 00 Y    ...
    . 38: 00 00 00 00 00 00 02 00 ........
                            **

A sequential file is designated by an $81 in the directory. The first block
of this file is stored on track 17 ($11), sector 1 ($01). We also see that
`"   DIRECTORY   "` is two blocks long (2 + 0 * 256). Let's take a look at
the first half of the starting data block.

             TRACK 17 - SECTOR 01

    . 00: 11 OB 43 36 34 20 53 54 ..C64 ST
    . 08: 41 52 54 45 52 20 4B 49 ARTER KI
    . 10: 54 20 20 20 36 34 20 20 T   64
    . 18: 32 41 OD 31 35 34 31 20 2A.1541
    . 20: 42 41 43 4B 55 50 0D 41 BACKUP.A
    . 28: 4D 4F 52 54 20 54 41 42 MORT TAB
    . 30: 4C 45 0D 41 52 52 4F 57 LE.ARROW
    . 38: 0D 42 49 54 53 20 41 4E .BITS AN
    . 40: 44 20 42 59 54 45 53 0D D BYTES.
    . 48: 43 41 4C 45 4E 44 41 52 CALENDAR
    . 50: 0D 43 48 41 4E 47 45 20 .CHANGE
    . 58: 44 49 53 4B 0D 43 48 41 DISK.CHA
    . 60: 52 20 42 4F 4F 54 0D 43 R BOOT.C
    . 68: 4F 4C 4F 52 20 54 45 53 OLOR TES
    . 70: 54 0D 43 4F 50 59 2D 41 T.COPY-A
    . 78: 4C 4C 36 34 0D 44 45 4D LL64.DEM

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Bytes 0 and 1 are the track and sector link (forward pointer). They inform us
that the next data block can be found at track 17, sector 11. The remaining
254 bytes are data. The sequential data that appear here are in fact the disk
name (C64 STARTER KIT), the cosmetic disk ID (64), and the file names found
on the C-64 DISK BONUS PACK. It is interesting to note that a carriage return
character ($0D) was used as a delimiter to separate record entries. Next we
see:

             TRACK 17 - SECTOR 11

    . 00: 00 86 2D 20 59 41 4E 4B ..- YANK
    . 08: 45 45 0D 53 4F 55 4E 44 EE.SOUND
    . 10: 20 2D 20 41 4C 49 45 4E  - ALIEN
    . 18: 0D 53 4F 55 4E 44 20 2D .SOUND -
    . 20: 20 42 4F 4D 42 0D 53 4F  BOMB.SO
    . 28: 55 4E 44 20 2D 20 43 4C UND - CL
    . 30: 41 50 0D 53 4F 55 4E 44 AP.SOUND
    . 38: 20 2D 20 47 55 4E 46 49  - GUNFI
    . 40: 52 45 0D 53 4F 55 4E 44 RE.SOUND
    . 48: 20 2D 20 50 4F 4E 47 0D  - PONG.
    . 50: 53 4F 55 4E 44 20 2D 20 SOUND -
    . 58: 52 41 59 47 55 4E 0D 53 RAYGUN.S
    . 60: 4F 55 4E 44 20 2D 20 53 OUND - S
    . 68: 49 52 45 4E 0D 53 50 52 IREN.SPR
    . 70: 49 54 45 20 42 4F 4F 54 ITE BOOT
    . 78: 0D 53 55 50 45 52 4D 4F .SUPERMO
    . 80: 4E 36 34 2E 56 31 0D 59 N64.V1.Y
    . 88: 54 53 50 52 49 54 45 53 TSPRITES
    . 90: A0 A0 A0 A0 A0 00 00 00 ........
    . 98: 00 00 00 00 00 00 05 00 ........
    . A0: 00 00 82 07 00 53 4E 4F .....SNO
    . A8: 4F 50 59 20 4D 41 54 48 OPY MATH
    . B0: A0 A0 A0 A0 A0 00 00 00 ........
    . B8: 00 00 00 00 00 00 33 00 ......3.
    . C0: 00 00 82 1D 00 41 4D 4F .....AMO
    . C8: 52 54 20 54 41 42 4C 45 RT TABLE
    . D0: A0 A0 A0 A0 A0 00 00 00 ........
    . D8: 00 00 00 00 00 00 27 00 ......'.
    . E0: 00 00 82 05 02 4D 4F 52 .....MOR
    . E8: 54 47 41 47 45 A0 A0 A0 TGAGE...
    . F0: A0 A0 A0 A0 A0 00 00 00 ........
    . F8: 00 00 00 00 00 00 2D 00 ......-.

We can see from the above data block that this is the last sector in the
chain. Byte 0 contains a zero indicating no forward track. Byte 1 then is a
byte count ($86=134). Byte 134 is the last byte in our data file. Recall that
the status variable (ST) will be set to 64 on the C64 side after byte 134 has
been read.

    . 80: 4E 36 34 2E 56 31 0D xx N64.V1.

The remainder of the block has been padded ($87—$FF). The padding is clearly
recognizable this time around. It has no rhyme or reason but it is still
interesting to say the least. A portion of the C-64 DISK BONUS PACK directory
itself was used to pad the remainder of the data block in question.

    . 80: xx xx xx xx xx xx xx 59 N64.V1.Y
    . 88: 54 53 50 52 49 54 45 53 TSPRITES
    . 90: A0 A0 A0 A0 A0 00 00 00 ........
    . 98: 00 00 00 00 00 00 05 00 ........
    . A0: 00 00 82 07 00 53 4E 4F .....SNO
    . A8: 4F 50 59 20 4D 41 54 48 OPY MATH
    . B0: A0 A0 A0 A0 A0 00 00 00 ........
    . B8: 00 00 00 00 00 00 33 00 ......3.
    . C0: 00 00 82 1D 00 41 4D 4F .....AMO
    . C8: 52 54 20 54 41 42 4C 45 RT TABLE
    . D0: A0 A0 A0 A0 A0 00 00 00 ........
    . D8: 00 00 00 00 00 00 27 00 ......'.
    . E0: 00 00 82 05 02 4D 4F 52 .....MOR
    . E8: 54 47 41 47 45 A0 A0 A0 TGAGE...
    . F0: A0 A0 A0 A0 A0 00 00 00 ........
    . F8: 00 00 00 00 00 00 2D 00 ......-.


## 4.7 Relative File Storage

Relative file types have the most elaborate internal structure. Relative
files are often referred to as random access files. A relative file is
actually two files in one:

1. A sequential data file with records of a fixed length.
2. A file of track and sector pointers called side sectors.

The sequential data file uses fixed length records so that the DOS can
calculate where to find any given record. This makes it possible to position
to a particular record and read or write it without disturbing the rest of
the file. In the jargon of relative files, the length of one record in the
sequential data file is known as the *record size*.

The complete file of track and sectors pointers is called the *side sector
file*. The size of this file depends on the length of the sequential file. In
general it is 1/120th the length of the sequential file (minimum length = 1
block; maximum length = 6 blocks). Each block in this file is known as
a *side sector*. There are really two sets of track and sector pointers in this
file. The larger set is a list of the track and sector numbers of the blocks
used to store the sequential data file (its file chain). The other is a list
of the track and sector numbers of the side sectors (the file chain of the
side sector file).

The purpose of the side sector file is to allow the DOS to find any given
record with remarkable efficiency. One disk read of a side sector is all that
is required to locate the track and sector of the block where a particular
record is stored. Two additional reads may then be required to retrieve a
record itself if it spans two data blocks. This will be explained shortly
when we examine records in more detail.

Remember that sequential data blocks have the following format:

Byte     | Purpose
:------- |:------------------------------------------------------------------
         |
0        | Track of the next block in this file
1        | Sector of the next block in this file
         |
2-255    | 254 bytes of data


Diagrammatically, each block (side sector) in the side sector file looks like
this:

    +-------+--------+---------+--------+--------------+---------------+
    | TRACK | SECTOR | SIDE    | RECORD | TRACK/SECTOR | TRACK/SECTOR  |
    | LINK  | LINK   | SECTOR  | SIZE   | LINKS FOR 6  | LINKS FOR 120 |
    |       |        | NUMBER  |        | SIDE SECTORS | DATA BLOCKS   |
    +-------+--------+---------+--------+--------------+---------------+


Byte    | Purpose
:------ |:-------------------------------------------------------------------
0       | Track of the next side sector
1       | Sector of the next side sector
        |
2       | Side sector number
        |
3       | Record length
        |
4-15    | Track and sector list of the side sector file
        |
        |  4-5  Track and sector of side sector #0
        |  6-7  Track and sector of side sector #1
        |  8-9  Track and sector of side sector #2
        | 10-11 Track and sector of side sector #3
        | 12-13 Track and sector of side sector #4
        | 14-15 Track and sector of side sector #5
        |
16-256  | Track and sector list of 120 data blocks
        |
        | 16-17 Track and sector of data block #1
        | 18-19 Track and sector of data block #2
        | 20-21 Track and sector of data block #3
        |  \
        |  /
        |  \
        |  \/
        | 254-255 Track and sector of data block #120


To help you make some sense out of this, let's begin with the directory entry
for a relative file. Here's the start of the directory of a diskette that has
a relative file stored on it.

             TRACK 18 - SECTOR 01

    . 00: 00 FF 81 11 00 53 43 20 .....SC
    . 08: 31 4D 41 47 20 46 49 4C 1MAG FIL
    . 10: 45 A0 A0 A0 A0 00 00 00 E.......
    . 18: 00 00 00 00 00 00 01 00 ........
    . 20: 00 00 81 11 01 53 43 20 .....SC
    . 28: 32 4D 41 47 20 46 49 4C 2MAG FIL
    . 30: 45 A0 A0 A0 A0 00 00 00 E.......
    . 38: 00 00 00 00 00 00 01 00 ........
    . 40: 00 00 81 11 02 53 43 20 .....SC
    . 48: 33 4D 41 47 20 46 49 4C 3MAG FIL
    . 50: 45 A0 A0 A0 A0 00 00 00 E.......
    . 58: 00 00 00 00 00 00 01 00 ........
    . 60: 00 00 84 11 03 4D 41 47 .....MAG      Here's the entry
    . 68: 20 46 49 4C 45 A0 A0 A0  FILE...      for the REL file:
    . 70: AO A0 A0 A0 A0 11 0D 96 ........
    . 78: 00 00 00 00 00 00 B4 01 ........

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"MAG FILE" will serve as our demo throughout this section. Let's examine its
directory entry in detail from track 18, sector 1.


    . 60: 00 00 84 11 03 4D 41 47 .....MAG
                ** ** **                        File type and T/S link
    . 68: 20 46 49 4C 45 A0 A0 A0  FILE...
    . 70: AO A0 A0 A0 A0 11 0D 96 ........
    . 78: 00 00 00 00 00 00 B4 01 ........

From the directory entry we can see that "MAG FILE" is a relative file. A
relative file is indicated by an $84 as the file type. The track and sector
pointers in the directory reveal that "MAG FILE" starts at track 17 ($11),
sector 03 ($03). This is the sequential data file portion of the relative
file. It is the beginning of our data.

    . 70: AO A0 A0 A0 A0 11 0D 96 ........
                         ** **                  Side sector information

Side sector information follows the file name. The first side sector begins
at track 17 ($11), sector 13 ($0D).

    . 70: AO A0 A0 A0 A0 11 0D 96 ........
                               **               Record length

In addition, we see our record length ($96=150). Each record in our
sequential data file is 150 bytes long. This is fixed throughout the entire
data file.

    . 78: 00 00 00 00 00 00 B4 01 ........
                            ** **               File length (lo/hi-byte)

Our sample relative file consumes a total of 436 blocks on the diskette (180
+ 1 * 256). (There is still room for expansion.) We can determine the number
of side sectors by simple division. A side sector stores track and sector
pointers for 120 data blocks of our sequential file. To determine the number
of side sectors, simply divide the total number of blocks that appear in the
directory entry by 120 and round up to the next higher integer:

436 / 120 = 3.6 -> 4

Four side sectors are needed to keep track of this much data. To figure out
how many records currently exist requires a little more arithmetic. First we
have to subtract the number of side sectors from the total number of blocks.

436 - 4 = 432

Now we can determine the total number of data bytes currently in use by our
sequential file.

432 * 254 = 109728

Why 254 as a multiplier? Remember that the first two bytes of any data block
are forward track and sector pointers (256 - 2 = 254). We finish our set of
calculations by dividing this total by the fixed record length.

109728 / 150 = 731.52

A total of 731 records exist at the current time in "MAG FILE."

Let's examine the first side sector.

             TRACK 17 - SECTOR 13 SIDE SECTOR #0

    . 00: 0C 13 00 96 11 0D 0C 13 ........  Forward pointer, SS #, size, and
    . 08: 06 10 13 0F 00 00 00 00 ........  6 pairs of side sector pointers
    . 10: 11 03 11 0E 11 04 11 0F ........  120 pairs of data block
    . 18: 11 05 11 10 11 06 11 11 ........  pointers
    . 20: 11 07 11 12 11 08 11 13 ........
    . 28: 11 09 11 14 11 0A 11 0B ........
    . 30: 11 0C 10 00 10 0A 10 14 ........
    . 38: 10 08 10 12 10 06 10 10 ........
    . 40: 10 04 10 0E 10 02 10 0C ........
    . 48: 10 01 10 0B 10 03 10 0D ........
    . 50: 10 05 10 0F 10 07 10 11 ........
    . 58: 10 09 10 13 0F 07 0F 11 ........
    . 60: 0F 05 0F 0F 0F 03 0F 0D ........
    . 68: 0F 01 0F 0B 0F 00 0F 0A ........
    . 70: 0F 14 0F 08 0F 12 0F 06 ........
    . 78: 0F 10 0F 04 0F 0E 0F 02 ........
    . 80: 0F 0C 0F 09 0F 13 0E 07 ........
    . 88: 0E 11 0E 05 0E 0F 0E 03 ........
    . 90: 0E 0D 0E 01 0E 0B 0E 00 ........
    . 98: 0E 0A 0E 14 0E 08 0E 12 ........
    . A0: 0E 06 0E 10 0E 04 0E 0E ........
    . A8: 0E 02 0E 0C 0E 09 0E 13 ........
    . B0: 0D 07 0D 11 0D 05 0D 0F ........
    . B8: 0D 03 0D 0D 0D 01 0D 0B ........
    . C0: 0D 00 0D 0A 0D 14 0D 08 ........
    . C8: 0D 12 0D 06 0D 10 0D 04 ........
    . D0: 0D 0E 0D 02 0D 0C 0D 09 ........
    . D8: 0D 13 0C 07 0C 11 0C 05 ........
    . E0: 0C 0F 0C 03 0C 0D 0C 01 ........
    . E8: 0C 0B 0C 00 0C 0A 0C 14 ........
    . F0: 0C 08 0C 12 0C 06 0C 10 ........
    . F8: 0C 04 0C 0E 0C 02 0C 0C ........


Of primary interest are the first 16 bytes.

    . 00: 0C 13 00 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........

Bytes 0 and 1 show us that the next side sector resides at track 12 ($0C),
sector 19 ($13). Byte 2 informs us that this is side sector 0. A maximum of 6
side sectors are used by any one relative file. This is determined solely by
the physical storage capacity of the diskette (664 blocks free after
formatting divided by 120 track and sector pointers in a side sector equals
5.53 side sectors). Side sectors are numbered from 0 to 5. Byte 3 shows us
the record size again (150 bytes). Bytes 5-15 are the track and sector
locations of the six possible side sectors. They can be tabled as follows:


 BYTE | SIDE SECTOR |   TRACK - SECTOR
 ----:|:-----------:|:-------------------:
 4- 5 |      0      | 17 ($11) - 13 ($0D)
 6- 7 |      1      | 12 ($0C) - 19 ($13)
 8- 9 |      2      |  6 ($06) - 16 ($10)
10-11 |      3      | 19 ($13) - 15 ($0F)
12-13 |      4      |  0 ($00) - 0 ($00)
14-15 |      5      |  0 ($00) - 0 ($00)


We can see from the table above that side sectors 4 and 5 have not yet been
allocated. Once our data file expands to encompass more than 480 and 600
sectors, respectively, they will be allocated, provided there is room on the
diskette.

The remaining 240 bytes are track and sector pointers to the first 120 blocks
in the sequential file. From bytes 16 and 17 of side sector 0 we see that our
data begins at track 17 ($11), sector 03 ($03). (This is the track and sector
recorded in the directory itself.) Track 17, sector 03 chains to track 17
($11), sector 14 ($0E) which chains to track 17 ($11), sector 4 ($04) and so
on.

             TRACK 17 - SECTOR 13                   SIDE SECTOR #0

    . 10: 11 03 11 0E 11 04 11 0F
          ** **
    . 18: 11 05 11 10 11 06 11 11 ........
    . 20: 11 07 11 12 11 08 11 13 ........
    . 28: 11 09 11 14 11 0A 11 0B ........
    . 30: 11 0C 10 00 10 0A 10 14 ........
    . 38: 10 08 10 12 10 06 10 10 ........
    . 40: 10 04 10 0E 10 02 10 0C ........
    . 48: 10 01 10 0B 10 03 10 0D ........
    . 50: 10 05 10 0F 10 07 10 11 ........
    . 58: 10 09 10 13 0F 07 0F 11 ........
    . 60: 0F 05 0F 0F 0F 03 0F 0D ........
    . 68: 0F 01 0F 0B 0F 00 0F 0A ........
    . 70: 0F 14 0F 08 0F 12 0F 06 ........
    . 78: 0F 10 0F 04 0F 0E 0F 02 ........
    . 80: 0F 0C 0F 09 0F 13 0E 07 ........
    . 88: 0E 11 0E 05 0E 0F 0E 03 ........
    . 90: 0E 0D 0E 01 0E 0B 0E 00 ........
    . 98: 0E 0A 0E 14 0E 08 0E 12 ........
    . A0: 0E 06 0E 10 0E 04 0E 0E ........
    . A8: 0E 02 0E 0C 0E 09 0E 13 ........
    . B0: 0D 07 0D 11 0D 05 0D 0F ........
    . B8: 0D 03 0D 0D 0D 01 0D 0B ........
    . C0: 0D 00 0D 0A 0D 14 0D 08 ........
    . C8: 0D 12 0D 06 0D 10 0D 04 ........
    . D0: 0D 0E 0D 02 0D 0C 0D 09 ........
    . D8: 0D 13 0C 07 0C 11 0C 05 ........
    . E0: 0C 0F 0C 03 0C 0D 0C 01 ........
    . E8: 0C 0B 0C 00 0C 0A 0C 14 ........
    . F0: 0C 08 0C 12 0C 06 0C 10 ........
    . F8: 0C 04 0C 0E 0C 02 0C 0C ........

Let's trace the remaining side sectors now.

             TRACK 12 - SECTOR 19                   SIDE SECTOR #1

    . 00: 06 10 01 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........
    . 10: 0C 09 0B 13 0B 07 0B 11 ........
    . 18: 0B 05 0B 0F 0B 03 0B 0D ........
    . 20: 0B 01 0B 0B 0B 00 0B 0A ........
    . 28: 0B 14 0B 08 0B 12 0B 06 ........
    . 30: 0B 10 0B 04 0B 0E 0B 02 ........
    . 38: 0B 0C 0B 09 0A 13 0A 07 ........
    . 40: 0A 11 0A 05 0A 0F 0A 03 ........
    . 48: 0A 0D 0A 01 0A 0B 0A 00 ........
    . 50: 0A 0A 0A 14 0A 08 0A 12 ........
    . 58: 0A 06 0A 10 0A 04 0A 0E ........
    . 60: 0A 02 0A 0C 0A 09 09 13 ........
    . 68: 09 07 09 11 09 05 09 0F ........
    . 70: 09 03 09 0D 09 01 09 0B ........
    . 78: 09 00 09 0A 09 14 09 08 ........
    . 80: 09 12 09 06 09 10 09 04 ........
    . 88: 09 0E 09 02 09 0C 09 09 ........
    . 90: 08 13 08 07 08 11 08 05 ........
    . 98: 08 0F 08 03 08 0D 08 01 ........
    . A0: 08 0B 08 00 08 0A 08 14 ........
    . A8: 08 08 08 12 08 06 08 10 ........
    . B0: 08 04 08 0E 08 02 08 0C ........
    . B8: 08 09 07 13 07 07 07 11 ........
    . C0: 07 05 07 0F 07 03 07 0D ........
    . C8: 07 01 07 0B 07 00 07 0A ........
    . D0: 07 14 07 08 07 12 07 06 ........
    . D8: 07 10 07 04 07 0E 07 02 ........
    . EO: 07 0C 07 09 06 13 06 07 ........
    . E8: 06 11 06 05 06 0F 06 03 ........
    . F0: 06 0D 06 01 06 0B 06 00 ........
    . F8: 06 0A 06 14 06 08 06 12 ........

Side sector 1 looks OK on this end.

             TRACK 06 - SECTOR 16                   SIDE SECTOR #2

    . 00: 13 0F 02 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........
    . 10: 06 06 06 02 06 0C 06 04 ........
    . 18: 06 0E 06 09 05 13 05 07 ........
    . 20: 05 11 05 05 05 0F 05 03 ........
    . 28: 05 0D 05 01 05 0B 05 00 ........
    . 30: 05 0A 05 14 05 08 05 12 ........
    . 38: 05 06 05 10 05 04 05 0E ........
    . 40: 05 02 05 0C 05 09 04 13 ........
    . 48: 04 07 04 11 04 05 04 0F ........
    . 50: 04 03 04 0D 04 01 04 0B ........
    . 58: 04 00 04 0A 04 14 04 08 ........
    . 60: 04 12 04 06 04 10 04 04 ........
    . 68: 04 0E 04 02 04 0C 04 09 ........
    . 70: 03 13 03 07 03 11 03 05 ........
    . 78: 03 0F 03 03 03 0D 03 01 ........
    . 80: 03 0B 03 00 03 0A 03 14 ........
    . 88: 03 08 03 12 03 06 03 10 ........
    . 90: 03 04 03 0E 03 02 03 0C ........
    . 98: 03 09 02 13 02 07 02 11 ........
    . A0: 02 05 02 0F 02 03 02 0D ........
    . A8: 02 01 02 0B 02 00 02 0A ........
    . B0: 02 14 02 08 02 12 02 06 ........
    . B8: 02 10 02 04 02 0E 02 02 ........
    . C0: 02 0C 02 09 01 13 01 07 ........
    . C8: 01 11 01 05 01 0F 01 03 ........
    . D0: 01 0D 01 01 01 0B 01 00 ........
    . D8: 01 0A 01 14 01 08 01 12 ........
    . E0: 01 06 01 10 01 04 01 0E ........
    . E8: 01 02 01 0C 01 09 13 0A ........
    . F0: 13 00 13 0B 13 01 13 0C ........
    . F8: 13 02 13 0D 13 03 13 0E ........

Side sector 2 seems to be in order too.

             TRACK 19 - SECTOR 15                   SIDE SECTOR #3

    . 00: 00 9F 03 96 11 0D 0C 13 ........
    . 08: 06 10 13 0F 00 00 00 00 ........
    . 10: 13 04 13 10 13 06 13 11 ........
    . 18: 13 07 13 12 13 08 13 05 ........
    . 20: 13 09 14 00 14 0A 14 01 ........
    . 28: 14 0B 14 02 14 0C 14 03 ........
    . 30: 14 0D 14 04 14 0E 14 05 ........
    . 38: 14 0F 14 06 14 10 14 07 ........
    . 40: 14 11 14 08 14 12 14 09 ........
    . 48: 15 00 15 0A 15 01 15 0B ........
    . 50: 15 02 15 0C 15 03 15 0D ........
    . 58: 15 04 15 0E 15 05 15 0F ........
    . 60: 15 06 15 10 15 07 15 11 ........
    . 68: 15 08 15 12 15 09 16 00 ........
    . 70: 16 0A 16 01 16 0B 16 02 ........
    . 78: 16 0C 16 03 16 0D 16 04 ........
    . 80: 16 0E 16 05 16 0F 16 06 ........
    . 88: 16 10 16 07 16 11 16 08 ........
    . 90: 16 12 16 09 17 00 17 0A ........
    . 98: 17 01 17 0B 17 02 17 0C ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

Hold it right there please. Bytes 0 and 1 should look familiar by now. Still
thinking? (Hint: End of chain and a byte count.)

    . 00: 00 9F 03 96 11 0D 0C 13 ........
          ** **

Byte 1 of side sector 3 shows a byte count of 159 ($9F). Recall that bytes
16-255 in a side sector are a list of track and sector pointers to 120 data
blocks. As a result, bytes 158 and 159 must be interpreted together. They
point to the last block in our sequential data file in this instance. The
last block is stored on track 23 ($17), sector 12 ($0C). Notice too, that the
remainder of the side sector is padded with nulls. The remaining 96 bytes are
in limbo until our relative file is expanded. Bytes 160 and 161 will then
point to the next track and sector of data and so on. When side sector 3 is
full, a new side sector will be created. Bytes 0 and 1 of side sector 3 will
then point to side sector 4. Bytes 12 and 13 in side sectors 0, 1, and 2 will
also be updated to reflect the creation of side sector 4.

Now let's take a brief glance at the sequential file itself.

             TRACK 17 - SECTOR 03

    . OO: 11 0E 4D 41 47 20 46 49 ..MAG FI
    . 08: 4C 45 0D 20 37 30 39 0D LE. 709.
    . 10: 20 36 0D D4 49 54 4C 45  6..ITLE
    . 18: 0D C3 4F 4D 50 55 54 45 ..OMPUTE
    . 20: 52 0D CD 41 47 41 5A 49 R..AGAZI
    . 28: 4E 45 0D C9 53 53 55 45 NE..SSUE
    . 30: 0D D0 41 47 45 0D C3 4F ..AGE..O
    . 38: 4D 4D 45 4E 54 0D 0D 00 MMENT...
    . 40: 00 00 00 00 00 00 00 00 ........
    . 48: 00 00 00 00 00 00 00 00 ........
    . 50: 00 00 00 00 00 00 00 00 ........
    . 58: 00 00 00 00 00 00 00 00 ........
    . 60: 00 00 00 00 00 00 00 00 ........
    . 68: 00 00 00 00 00 00 00 00 ........
    . 70: 00 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 00 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 20 31 35 30 20 0D 2E 0D  150 ...
    . A0: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . A8: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . B0: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . B8: 2E 0D 2E 0D 2E 0D 2E 0D ........
    . C0: 2E 0D 2E 0D 2E 0D 00 00 ........
    . CB: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

The block reveals a typical sequential file. Bytes 0 and 1 are the chain. The
first data block links to track 17 ($11), sector 14 ($0E). The next 150 bytes
(2 - 151) constitute our first record. Note that the unused bytes within a
record are written as nulls ($00) by the DOS so the record is always a fixed
length. The content of individual records will vary enormously. This is
program dependent so the data block in question contains whatever data was
specified by the program used. This particular record is from a free form
data base. It was reserved to for management information by the main program
and contains the following data:

1. The name of our relative file ("MAG FILE").
2. The number of active records (709).
3. The number of fields in use (6).
4. The field titles (TITLE, COMPUTER, MAGAZINE, ISSUE, PAGE, COMMENT).

In the sequential data file portion of a relative file, the record length
(record size) is constant. In this case, the records are all 150 bytes long.
Record number 2 begins at byte 152 ($98) and will extend on into the next
data block. Two reads would be required to fetch the entire contents of this
record. The first 104 bytes of the record will be found here, but the
remaining 46 are in the next block of the file. Here they are.

             TRACK 17 - SECTOR 14

    . 00: 11 04 00 00 00 00 00 00 ........
    . 08: 00 00 00 00 00 00 00 00 ........
    . 10: 00 00 00 00 00 00 00 00 ........
    . 18: 00 00 00 00 00 00 00 00 ........
    . 20: 00 00 00 00 00 00 00 00 ........
    . 28: 00 00 00 00 00 00 00 00 ........
    . 30: D3 4F 55 4E 44 20 D3 59 .OUND .Y
    . 38: 4E 54 48 45 53 49 53 0D NTHESIS.
    . 40: 41 4C 4C 0D C3 4F 4D 50 ALL..OMP
    . 48: 55 54 45 0D CA 41 4E 20 UTE..AN
    . 50: 38 33 0D 32 36 0D 2E 0D 83.26...
    . 58: 0D 2E 0D 2E 0D 2E 0D 2E ........
    . 60: 0D 2E 0D 2E 0D 2E 0D 2E ........
    . 68: 0D 2E 0D 2E 0D 2E 0D 2E ........
    . 70: 0D 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 00 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 00 00 00 00 00 00 00 00 ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 D7 52 .......R
    . C8: 49 54 49 4E 47 20 D4 52 ITING .R
    . D0: 41 4E 53 50 4F 52 54 41 ANSPORTA
    . D8: 42 4C 45 20 C2 41 53 49 BLE .ASI
    . E0: 43 0D 41 4C 4C 0D C3 4F C.ALL..0
    . E8: 4D 50 55 54 45 0D CA 41 MPUTE..A
    . F0: 4E 20 38 33 0D 33 36 0D N 83.36.
    . F8: 2E 0D 0D 2E 0D 2E 0D 2E ........

Record number 2 is used again for management information by our data base. It
simply contains the record length. One can see from the number of carriage
returns ($0D) that while only 6 fields are in use, 21 were established by the
main program. One can also see that a blank field from this data base is
stored as a period ($2E = CHR$(46) = "."). Record number 3 begins at byte 48.
It contains our first actual data. It would look like so:

    Title:      Sound Synthesis
    Computer:   All
    Magazine:   Compute (sic)
    Issue:      Jan 83
    Page:       26
    Comment:    (none)

Just out of curiosity let's examine the last two sectors of our sequential
file chain as reported in bytes 156-159 of side sector 3. Why two sectors?
Our fixed length of 150 bytes dictates this. (A fixed record length of 1, 2,
127, or 254 would not span a given sector. The maximum length of a relative
record is 254 bytes. 254 is the only number evenly divisible by these
factors. A record length of 1 or 2 would be rather impractical.)

             TRACK 23 - SECTOR 02

    . 00: 17 0C 00 00 00 00 00 00 ........
    . 08: 00 00 00 00 00 00 00 00 ........
    . 10: 00 00 00 00 00 00 00 00 ........
    . 18: 00 00 00 00 00 00 00 00 ........
    . 20: 00 00 00 00 00 00 00 00 ........
    . 28: 00 00 00 00 00 00 00 00 ........
    . 30: 00 00 00 00 00 00 00 00 ........
    . 38: 00 00 00 00 00 00 00 00 ........
    . 40: 00 00 00 00 00 00 00 00 ........
    . 48: 00 00 00 00 00 00 00 00 ........
    . 50: 00 00 00 00 00 00 00 00 ........
    . 58: 00 00 00 00 00 00 00 00 ........
    . 60: 00 00 00 00 00 00 00 00 ........
    . 68: 00 00 00 00 00 00 00 00 ........
    . 70: 00 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 FF 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 00 00 00 00 00 00 00 00 ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 00 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........


             TRACK 23 - SECTOR 12

    . 00: 00 B1 00 00 00 00 00 00 ........
    . 08: 00 00 00 00 00 00 00 00 ........
    . 10: 00 00 00 00 00 00 00 00 ........
    . 18: 00 00 00 00 FF 00 00 00 ........
    . 20: 00 00 00 00 00 00 00 00 ........
    . 28: 00 00 00 00 00 00 00 00 ........
    . 30: 00 00 00 00 00 00 00 00 ........
    . 38: 00 00 00 00 00 00 00 00 ........
    . 40: 00 00 00 00 00 00 00 00 ........
    . 48: 00 00 00 00 00 00 00 00 ........
    . 50: 00 00 00 00 00 00 00 00 ........
    . 58: 00 00 00 00 00 00 00 00 ........
    . 60: 00 00 00 00 00 00 00 00 ........
    . 68: 00 00 00 00 00 00 00 00 ........
    . 70: 00 00 00 00 00 00 00 00 ........
    . 78: 00 00 00 00 00 00 00 00 ........
    . 80: 00 00 00 00 00 00 00 00 ........
    . 88: 00 00 00 00 00 00 00 00 ........
    . 90: 00 00 00 00 00 00 00 00 ........
    . 98: 00 00 00 00 00 00 00 00 ........
    . A0: 00 00 00 00 00 00 00 00 ........
    . A8: 00 00 00 00 00 00 00 00 ........
    . B0: 00 00 FF 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . C8: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

An analysis of the preceding two sectors will all but end our discussion on
relative file structure. Bytes 2-131 of track 23, sector 2 are the overflow
of a previous record. Bytes 132-255 of this same track and bytes 2-27 of
track 23, sector 12 make up the next record. This record is empty, as
indicated by a 255 ($FF) in the first byte and nulls in the remaining bytes.
Track 23, sector 12 has no forward chain and a byte count of 177 ($B1). Our
last record in the relative file ends at byte 177 (28-177). What is
interesting is the padding beyond this point:

    . B0: xx xx FF 00 00 00 00 00 ........
    . B8: 00 00 00 00 00 00 00 00 ........
    . C0: 00 00 00 00 00 00 00 00 ........
    . CA: 00 00 00 00 00 00 00 00 ........
    . D0: 00 00 00 00 00 00 00 00 ........
    . D8: 00 00 00 00 00 00 00 00 ........
    . E0: 00 00 00 00 00 00 00 00 ........
    . E8: 00 00 00 00 00 00 00 00 ........
    . F0: 00 00 00 00 00 00 00 00 ........
    . F8: 00 00 00 00 00 00 00 00 ........

We would expect to find all nulls ($00). Byte 178 ($B2), however, shows an
$FF, i.e., the start of a new record. The DOS is one step ahead of the game
when expansion time rolls around. A partial record has already been created
in this instance. The DOS need only calculate the difference between 255 and
the byte count to determine the number of nulls that must follow to complete
the record:

    255 - 177 = 78 bytes already in existence

It then takes the record size to figure out the padding needed:

    Total Record Length - Bytes in Existence = Nulls to Go
    150 - 78 = 72

Slick!

We will close our section on relative file structure by taking a brief look
at how the computer, or you, can locate a particular relative record. Pick a
number, any number. Record number 4 you say. No problem if you know the
record length.

First we find the appropriate side sector.

    4-1 = 3 previous records
    3 * 150 fixed length = 450th starting byte (i.e., 0 - 449 previous bytes)
    450 / 254 = 1.7716535
    INT (1.7716535) + 1 = pointer set 2
    Pointer set 2 / 120 sets of pointers in a side sector = 0.01666667
    INT (0.01666667) = side sector 0

Where in side sector 0 is it? Easy.

    Byte 14 + (pointer set 2 * 2 bytes in a pointer) = byte 18
    Bytes 18 and 19 will contain the track and sector of our record.

Where in the actual data block is it? A piece of cake.

    1.7716535 - INT(1.7716535) = remainder .7716535
    2 (skip over bytes 0 and 1) + (.7716535 * 254 bytes of data) = byte 198

Still a disbeliever? Check it out yourself in the preceding hex dumps of
track 17, sector 13 and track 17, sector 14.

## 4.8 User File Storage

A user file (USR) file is one that is designed by the user. This file type is
designated by an $83 in the directory. Although a user file is a legal
Commodore file type (USR), its use is quite rare. Using a USR file rather
than a more common file type is for showmanship only.

A user file may have the structure of either a sequential file or a program
file if it was created by the DOS. It may be structured entirely differently
if it was created using direct-access techniques described in Chapter 5.
Before you do something rash, remember that the DOS will expect to find the
track and sector links in their normal places. If they are not there, all the
blocks that make up your file will be earmarked as free in the BAM whenever
the disk is validated!

## 4.9 Deleted File Storage

A deleted file (DEL) has a file-type byte of $80 in the directory. This is
not a scratched file ($00), but an undocumented Commodore file type (DEL). It
is extremely rare. Only one vendor has dared use a DEL file on a commercial
product to date. It was not a functional file and was placed on the diskette
to intimidate users as part of a low level protection scheme.

You cannot create a DEL file using an OPEN statement. You can only create a
DEL file by changing the file-type byte of an existing file to $80 as
described in the next section. Since a DEL file is really another file type
in disguise, a DEL file may have the structure of either a sequential file or
a program file. If it has the structure of a program file, it may be loaded
using one of these commands:

    LOAD "FILE NAME,DEL,R",8 (RELOCATED)

    LOAD "FILE NAME,DEL,R",8,1 (NOT RELOCATED)

If a DEL file is structured like a sequential file, it may be opened in read
mode using the following command:

    OPEN 2,8,2,"FILE NAME,DEL,R"

## 4.10 Locked Files

Earlier in this chapter you may have been surprised to see locked files of
various form in the table of legal file types. Locked file types are once
again an undocumented feature of Commodore disk drives. A locked file cannot
be scratched unless it is first unlocked.

Unfortunately, the DOS does not support the locking or unlocking of a file.
You have to do-it-yourself by editing the file-type byte in the directory
entry for that file. The program EDIT TRACK & SECTOR listed in Appendix C
allows you to do this. We will not describe the technique here. See the
section on Unscratching a File in Chapter 8 for instructions on how to edit
the file-type byte. Use the values from the table below, rather than those
listed in Chapter 8, when locking or unlocking a file.


File Type  |  Normal |  Locked
:--------- |:-------:|:--------:
Deleted    | DEL $80 | DEL< $C0
Sequential | SEQ $81 | SEQ< $C1
Program    | PRG $82 | PRG< $C2
User       | USR $83 | USR< $C3
Relative   | REL $84 | REL< $C4


The DOS determines whether or not a file is locked by checking bit 6 of the
file-type byte. If it is set (1), the file is locked. Even if a file has been
locked, it may be renamed or copied using normal disk commands.

## Conclusion

The material covered in this chapter is primarily of academic interest.
However, do not attempt to recover a blown file unless you thoroughly
understand the structure of the directory and how files are stored.


# CHAPTER 5 - DIRECT-ACCESS PROGRAMMING

## 5.1 Introduction to Direct-Access Programming

In Chapter 2 you learned how to use such DOS commands as NEW, SCRATCH, and
VALIDATE, for diskette housekeeping. This chapter describes how to use
another set of DOS commands known as direct-access commands. These commands
are not commonly used in typical programming applications. However, they
allow you to step beyond simple housekeeping chores to develop more powerful
disk utility programs that do such things as:

* Change a disk name or cosmetic ID.
* Display a block availability map (the BAM).
* Display a directory.
* Display a track and sector.
* Chain through a directory entry.
* Edit a track and sector.
* Recover an inadvertently scratched file.
* Recover a damaged diskette.
* Duplicate a diskette.
* Copy a file.
* Catalog a disk library.

As you grow with your 1541, the need for routines of this nature will become
increasingly apparent, if it isn't already. This chapter illustrates the use
of direct-access commands in simple programs. A basic understanding of the
function of these commands is necessary to appreciate the routines found in
subsequent chapters and Appendix C.

## 5.2 Beginning Direct-Access Programming

The 1541 DOS recognizes nine direct-access commands. These direct-access
commands and their functions are listed below.


Direct-Access Command   | Function
:-----------------------|:---------------------------------------------------
Block-Read (U1)         | Read a data block into 1541 RAM.
Buffer-Pointer (B-P)    | Set pointer to any byte in a disk buffer.
Block-Write (U2)        | Write a data block from 1541 RAM to diskette.
Memory-Read (M-R)       | Peek bytes out of 1541 RAM or ROM.
Memory-Write (M-W)      | Poke bytes into 1541 RAM.
Block-Allocate (B-A)    | Set bit in BAM to indicate a sector is in use.
Block-Free (B-F)        | Set bit in BAM to indicate a sector is not in use.
Memory-Execute (M-E)    | Execute a 6502 routine stored in 1541 RAM or ROM.
Block-Execute (B-E)     | Load and execute a 6502 routine in 1541 RAM.


More often than not, direct-access commands complement one another in actual
use. For example, a sector can be read from disk using a U1 command, examined
using a B-P or M-R command, altered using a B-P or M-W command, and rewritten
to disk using a U2 command.

The block-read (U1), buffer-pointer, and block-write (U2) commands are the
easiest to comprehend and, as a result, the most widely used. The memory-read
and memory-write commands represent a more sophisticated level of
direct-access programming and are sometimes used in lieu of the
buffer-pointer command. The block-allocate and block-free commands are used
primarily for the maintenance of random access files. Random access files
were the forerunner of relative files and are rarely used today. The
memory-execute command is used at the guru level of disk programming and
requires a rudimentary knowledge of both machine language and the innards of
the 1541 to implement. The block-execute command, while documented by
Commodore, is almost never used.

In order to use the commands mentioned above you will need to learn how to
open a direct-access data channel. The format of a direct-access OPEN
statement is:

    SYNTAX:     OPEN file#, device#, channel#, "#"

    EXAMPLE:    OPEN 2,8,2,"#"
                OPEN 1,8,14,"#"

where

* file# = the logical file number (1 to 127)
* device# = 8
* channel# = the secondary address of the associated open statement (2 to 14)

Opening a direct-access data channel establishes a communication link between
the C64 and the 1541. In the first example, we opened logical file number 2
on the C64 side to device number 8 with a secondary address of 2 (channel
number 2) on the 1541 side. The only time a channel number is ever referenced
is as part of a direct-access command, e.g., a block-read command (U1). Data
is always read from disk (GET# file#, INPUT# file#,) or written to disk
(PRINT# file#,) by way of the logical file number of the direct-access OPEN
statement NOT the channel number. The logical file number and the channel
number do not have to match as they do in our first OPEN example. They are
two separate entities. The logical file number which resides on the C64 side
passes read or write commands to the channel number on the 1541 side. Any
similarity between the logical file number and the channel number is for
mnemonic purposes only. The second example is a perfectly legal direct-access
OPEN statement. In this instance, we opened logical file number 1 (GET#1,
PRINT#1,) to device number 8 with a secondary address of 14 (channel number
14) on the 1541 side. Whether or not you use mnemonic OPEN statements is
strictly a matter of personal preference.

We will begin our tutorial on direct-access programming with a quick review
of the 1541 format explained in Chapter 3. The table below outlines the range
of track and sector numbers found on a diskette.


  Zone  |    Track | Sector Range | Number of Sectors
:------:|---------:|:------------:|:-----------------:
   1    |   1 - 17 |    0 - 20    |          21
   2    |  18 - 24 |    0 - 18    |          19
   3    |  25 - 30 |    0 - 17    |          18
   4    |  31 - 35 |    0 - 16    |          17


NOTE: If you attempt to access a track less than 1, a track greater than 35,
or a sector out of range for a given track, you will get a DOS error message
number 66, ILLEGAL TRACK OR SECTOR.


## 5.3 Block-Read Command (U1)

The block-read command (U1) transfers the contents of a given track and
sector to an area of disk RAM commonly referred to as a buffer or workspace.
The format of a block- read command (U1) is:

    SYNTAX:
        PRINT# file#, "U1"; channel#; drive#; track; sector

    ALTERNATE:
        PRINT# file#, "U1:" channel#; drive#; track; sector
        PRINT# file#, "U1: channel#, drive#, track, sector"

    EXAMPLE:
        PRINT#15,"U1";2;0;18;0

where

* file# = the logical file number of the command channel
* channel# = the secondary address of the associated open statement
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

After a given track and sector has been transferred to a buffer with a
block-read command (U1), the buffer pointer is automatically left in position
255. Bytes 0-255 of the buffer are now accessible from the starting position,
i.e., byte 0. The GET# command is normally used to retrieve one byte at a
time from the buffer by way of the logical file number of the direct-access
OPEN statement. The GET# command is used rather than INPUT# because the data
may contain null bytes, carriage returns and/or line feeds, commas, colons,
or other control characters. When using the GET# command you must remember to
test each incoming byte for equality with the null string "".A null byte must
be converted to CHR$(0) or an ?ILLEGAL QUANTITY ERROR will result when you
try to find the ASCII value of the byte. (The GET# command fails to make the
necessary conversion for you.) The ASCII value of a byte is used to check for
control characters. These characters are misinterpreted by the INPUT#
command. The following example reads the block from track 18, sector 0 (the
BAM) into disk RAM and prints the contents to the screen.

    100 REM BLOCK-READ (U1)
    110 OPEN 15,8,15
    120 PRINT#15,"I0:"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 290
    150 OPEN 2,8,2,"#"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 270
    190 FOR I=0 TO 255
    200 GET#2,B$
    210 IF B$=""THEN B$=CHR$(0)
    220 A=ASC(B$)
    230 PRINT ST,I,A,
    240 IF A>31 AND A<96 THEN PRINT B$,
    250 PRINT
    260 NEXT I
    270 CLOSE 2
    280 INPUT#15,EN$,EM$,ET$,ES$
    290 CLOSE 15
    300 END


Line Range | Description
:--------- |:----------------------------------------------------------------
110        | Opens logical file number 15 (PRINT#15,) to device 8 with a
           | secondary address of 15 (command channel).
120        | Initializes drive 0.
130-140    | Query the error channel.
150        | Opens logical file number 2 (GET#2,) to device 8 with a
           | secondary address of 2 (channel number 2) letting the 1541
           | assign a buffer area.
160        | Reads the block from drive 0, track 18, sector 0 into channel 2
           | buffer area.
170-180    | Query the error channel.
190        | Begin loop to read 256 bytes.
200        | Transfer a byte from channel 2 buffer area to C 64 memory by way
           | of the GET# command (GET# logical file number not the channel
           | number).
210        | Test for equality with the null string "".
220        | ASCII conversion of a byte.
230        | Print the status variable (ST), our loop counter, and the ASCII
           | value of the byte.
240        | Print the byte if it's within normal ASCII range.
250        | Terminate comma tabulation.
260        | Increment loop counter.
270        | Close logical file number 2.
280        | Suppress the error light.
290        | Close logical file number 15.
300        | End.


An explanation of programming technique is in order here. Initialization
(line 120) is done prior to opening a direct-access data channel (line 150).
Initialization automatically shuts down all direct-access data channels (2
-14) that are open on the 1541 side. The command channel (15) is not
affected. Logical files still remain open on the C64 side, however. Any
attempt to access a data channel after initialization results in a 70, NO
CHANNEL error. The DOS attempts to rewrite the BAM each time a direct-access
channel is closed (line 270). If a diskette is either write protected or DOS
protected, the BAM is not rewritten and the error light remains on until
cleared. Fortunately, no damage has been done to the data on the diskette.
The error light is quite distracting nevertheless. You can suppress the error
light after closing a direct-access data channel simply by inputting the
error number, message, track, and sector via the command channel (line 280).

The alternate formats of the block-read command (U1) in line 160 are:

    PRINT#15,"U1:"2;0;18;0

    PRINT#15,"U1:2,0,18,0"

Although the block-read command (U1) comes in three basic flavors, line 160
uses the preferred format. It will be used in demonstration programs
throughout the chapter for consistency. Alternate formats will appear in
passing.

Additionally, lines 210-220 are often combined into one BASIC statement for
the sake of efficiency:

    A=ASC(B$+CHR$(0))

Recall that lines 210-220 are necessary because the GET# command does not
interpret nulls correctly.

## 5.4 Buffer-Pointer Command (B-P)

The buffer-pointer command allows access to any individual byte in a DOS
buffer. Any byte from position 0 through 255 in the buffer may be read or
overwritten. The format of a buffer-pointer command is:

    SYNTAX:
        PRINT# file#, "B-P"; channel#; byte position

    ALTERNATE:
        PRINT# file#, "B-P:" channel#; byte position
        PRINT# file#, "B-P: channel#, byte position"

    EXAMPLE:
        PRINT#15,"B-P";2;144

where

* file# = the logical file number of the command channel
* channel# = the secondary address of the associated open statement
* byte position = 0 to 255

The following program displays a disk name by reading only bytes 144 to 159
from track 18, sector 0.

    100 REM BUFFER-POINTER
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 320
    150 OPEN 2,8,2,"#"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 300
    190 PRINT#15,"B-P";2;144
    200 FOR I=1 TO 16
    210 GET#2,B$
    220 IF B$=""THEN B$=CHR$(0)
    230 A=ASC(B$)
    240 IF A>127 THEN A=A-128
    250 IF A<32 OR A>95 THEN A=63
    260 IF A=34 THEN A=63
    270 DN$=DN$+CHR$(A)
    280 NEXT I
    290 PRINT"{DOWN}DISK NAME: ";DN$
    300 CLOSE 2
    310 INPUT#15,EN$,EM$,ET$,ES$
    320 CLOSE 15
    330 END


Line Range | Description
:--------- |:----------------------------------------------------------------
190        | Sets channel 2 pointer to position 144 in the buffer area.
200-280    | Concatenate (build) the disk name one byte at a time by jamming
           | it within printable ASCII range.


    PRINT#15,"B-P:"2;144

    PRINT#15,"B-P:2,144"

## 5.5 Block-Write Command (U2)

The block-write command (U2) writes the data from a DOS buffer to any given
track and sector on a diskette. The format of a block-write command (U2)
parallels that of a block-read command (U1). The format of a block-write
command (U2) is:

SYNTAX:
    PRINT# file#, "U2"; channel#; drive#; track; sector

ALTERNATE:
    PRINT# file#, "U2:" channel#; drive#; track; sector
    PRINT# file#, "U2: channel#, drive#, track, sector"

EXAMPLE:
    PRINT#15,"U2";2;0;18;0

where

* file# = the logical file number of the command channel
* channel# = the secondary address of the associated open statement
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

The entire contents of a buffer are written to disk during the execution of a
block-write command (U2). The position of the buffer-pointer is irrelevant.
It is not referred to by the DOS during the execution of a block-write
command (U2).

The first program listed below allows a disk name to be changed using a
block-write command (U2). The second example allows you to edit the cosmetic
disk ID that appears in the BAM. NOTE: This program does not change the
formatting ID that is embedded in the header block of every sector.

    100 REM EDIT DISK NAME
    110 FOR I=1TO16
    120 PAD$=PAD$+CHR$(160)
    130 NEXTI
    140 PRINT"{CLR}EDIT DISK NAME - 1541"
    150 PRINT"{DOWN}REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    160 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    170 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    180 GETC$:IFC$=""THEN180
    190 IFC$<>CHR$(13)GOTO180
    200 PRINT"OK"
    210 OPEN15,8,15
    220 PRINT#15,"I0"
    230 INPUT#15,EN$,EM$,ET$,ES$
    240 IFEN$="00"GOTO280
    250 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    260 CLOSE15
    270 END
    280 OPEN 2,8,2,"#"
    290 PRINT#15,"U1";2;0;18;0
    300 INPUT#15,EN$,EM$,ET$,ES$
    310 PRINT#15,"B-P";2;2
    320 GET#2,B$
    330 IFB$=""THENB$=CHR$(0)
    340 DOS=ASC(B$)
    350 IFDOS=65GOTO390
    360 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,00"
    370 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    380 GOTO720
    390 PRINT#15,"B-P";2;144
    400 FORI=1TO 16
    410 GET#2,B$
    420 IFB$=""THENB$=CHR$(0)
    430 A=ASC(B$)
    440 IFA>127THENA=A-128
    450 IFA<32ORA>95THENA=63
    460 IFA=34THENA=63
    470 ODN$=ODN$+CHR$(A)
    480 NEXTI
    490 PRINT"{DOWN}OLD DISK NAME: ";ODN$
    500 INPUT"{DOWN}NEW DISK NAME";NDN$
    510 IFLEN(NDN$)<>0ANDLEN(NDN$)<17GOTO530
    520 GOTO720
    530 INPUT"{D0WN}ARE YOU SURE (Y/N)  Y{LEFT 3}";Q$
    540 IFQ$<>"Y"GOTO720
    550 NDN$=LEFT$(NDN$+PAD$,16)
    560 PRINT#15,"B-P";2;144
    570 PRINT#2,NDN$;
    580 PRINT#15."U2";2;0;18;0
    590 INPUT#15,EN$,EM$,ET$,ES$
    600 IFEN$="00"GOTO 640
    610 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    620 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    630 GOTO720
    640 CLOSE2
    650 INPUT#15,EN$,EM$,ET$,ES$
    660 PRINT#15,"I0"
    670 INPUT#15,EN$,EM$,ET$,ES$
    680 CLOSE15
    690 PRINT"{DOWN}DONE!"
    700 END
    710 REM CLOSE
    720 CLOSE2
    730 INPUT#15,EN$,EM$,ET$,ES$
    740 CLOSE15
    750 END


Line Range | Description
:--------- |:----------------------------------------------------------------
280        | Opens logical file number 2 (GET#2, PRINT#2,) to device 8 with a
           | secondary address of 2 (channel number 2) letting the 1541
           | assign a buffer area.
310-380    | Query DOS version.
550        | Pad new diskette name.
560        | Reset channel 2 pointer to position 144.
570        | Overwrite existing disk name in channel 2 buffer area.
580        | Write channel 2 buffer to drive 0, track 18, sector 0.
660        | Update the BAM ($0700-$07FF) to reflect a disk name change.


The alternate formats of the block-write command (U2) in line 580 are:

    PRINT#15,"U2:"2;0;18;0

    PRINT#15,"U2:2,0,18,0"


    100 REM EDIT DISK ID
    110 PRINT"{CLR}EDIT DISK ID - 1541"
    120 PRINT"{DOWN}REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    130 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    140 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    150 GETC$:IFC$=""THEN150
    160 IFC$<>CHR$(13)GOTO150
    170 PRINT"OK"
    180 OPEN 15,8,15
    190 PRINT#15,"I0"
    200 INPUT#15,EN$,EM$,ET$,ES$
    210 IFEN$="00"GOTO250
    220 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    230 CLOSE15
    240 END
    250 OPEN 2,8,2,"#"
    260 PRINT#15,"U1";2;0;18;0
    270 INPUT#15,EN$,EM$,ET$,ES$
    280 PRINT#15,"B-P";2;2
    290 GET#2,B$
    300 IFB$=""THENB$=CHR$(0)
    310 DOS=ASC(B$)
    320 IFDOS=65GOTO360
    330 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,00"
    340 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    350 GOTO690
    360 PRINT#15,"B-P";2;162
    370 FORI=1TO2
    380 GET#2,B$
    390 IFB$=""THENB$=CHR$(0)
    400 A=ASC(B$)
    410 IFA>127THENA=A-128
    420 IFA<32ORA>95THENA=63
    430 IFA=34THENA=63
    440 ODI$=ODI$+CHR$(A)
    450 NEXTI
    460 PRINT"{DOWN}OLD DISK ID: ";ODI$
    470 INPUT"{DOWN}NEW DISK ID";NDI$
    480 IFLEN(NDI$)<>0ANDLEN(NDI$)<3GOTO500
    490 GOTO690
    500 INPUT"{DOWN}ARE YOU SURE (Y/N)  Y{LEFT 3}";Q$
    510 IFQ$<>"Y"GOTO 690
    520 NDI$=LEFT$(NDI$+CHR$(0),2)
    530 PRINT#15,"B-P";2;162
    540 PRINT#2,NDI$;
    550 PRINT#15,"U2";2;0;18;0
    560 INPUT#15,EN$.EM$,ET$,ES$
    570 IFEN$="00"GOTO610
    580 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    590 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    600 GOTO690
    610 CLOSE2
    620 INPUT#15,EN$,EM$,ET$,ES$
    630 PRINT#15,"I0"
    640 INPUT#15,EN$,EM$,ET$,ES$
    650 CLOSE15
    660 PRINT"{DOWN}DONE!"
    670 END
    680 REM CLOSE
    690 CLOSE2
    700 INPUT#15,EN$,EM$,ET$,ES$
    710 CLOSE15
    720 END

The alternate formats of the block-write command (U2) in line 550 are:

    PRINT#15,"U2:"2;0;18;0

    PRINT#15,"U2:2,0,18,0"

That's enough about the block-write command (U2) for now.

## 5.6 Memory-Read Command (M-R)

The memory-read command allows you to read the contents of any area of the
1541's RAM or ROM. You must specify in the memory-read command the memory
address of RAM or ROM that you want to read. The format of a memory-read
command is:

    SYNTAX:
        PRINT# file#, "M-R" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes)

    ALTERNATE:
        PRINT# file#, "M-R:" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes)

    EXAMPLE:
        PRINT#15,"M-R"CHR$(0)CHR$(3)

where

* file# = the logical file number of the command channel
* lo-byte = lo-byte of the memory address
* hi-byte = hi-byte of the memory address
* # of bytes = 1 to 255

The third parameter of the memory-read command, CHR$(# of bytes), is
undocumented by Commodore. The use of the third parameter is always optional.
The default is CHR$(1), i.e., 1 byte.

Typically a block-read command (U1) is issued prior to a memory-read command.
A block-read command (U1) transfers the data that is recorded on a given
track and sector to one of four pages (256 bytes) of RAM. A page of RAM is
called a buffer. When you open a direct-access data channel to the 1541 with
OPEN 2,8,2,"#", the DOS arbitrarily selects one buffer as a workspace for
that channel. As long as you use the GET# file# command or the PRINT# file#
command from the associated OPEN statement you do not need to know which
buffer the DOS is using. The buffer in use is only important when you issue a
memory-read command. You may tell the DOS which buffer area to use in the
direct-access OPEN statement itself. The format for selecting a buffer is:

    SYNTAX:
        OPEN file#, device#, channel#, "# buffer#"

    EXAMPLE:
        OPEN 2,8,2,"#0"

where

* buffer# = 0 to 3

The table below shows how the buffer areas are organized in the 1541.


 Buffer Number |    Address    | Example
:-------------:|:-------------:|:--------------------------------------------
               | $0000 - $00FF | Not available (ZERO PAGE)
               | $0100 - $01FF | Not available (STACK)
               | $0200 - $02FF | Not available (COMMAND BUFFER)
       0       | $0300 - $03FF | OPEN 2,8,2,"#0"
       1       | $0400 - $04FF | OPEN 2,8,2,"#1"
       2       | $0500 - $05FF | OPEN 2,8,2,"#2"
       3       | $0600 - $06FF | OPEN 2,8,2,"#3"
               | $0700 - $07FF | Not available (BAM)


NOTE: Two or more direct-access data channels cannot share the same buffer
area. If you attempt to open a direct-access data channel to a buffer already
in use a 70, a NO CHANNEL error will result.

The GET# command is used following a memory-read command to retrieve the
contents of the buffer you selected. There is one major difference, however.
Bytes are now fetched over the command channel not the logical file number of
the "OPEN file#, device#, channel#, buffer#" statement. Bytes must still be
tested for equality with the null string "" and converted to CHR$(0) if need
be.

The next program selects buffer #0 ($0300 - $03FF) as a workspace and does a
block- read of track 18, sector 0. Bytes are returned to the C64 side from
buffer #0 with memory-read and GET# commands, and printed to the screen.


    100 REM TWO PARAMETER MEMORY-READ
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 300
    150 OPEN 2,8,2,"#0"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 280
    190 FOR I=0 TO 255
    200 PRINT#15,"M-R"CHR$(I)CHR$(3)
    210 GET#15,B$
    220 IF B$=""THEN B$=CHR$(0)
    230 A=ASC(B$)
    240 PRINT I,A,
    250 IF A>31 AND A<96 THEN PRINT B$,
    260 PRINT
    270 NEXT I
    280 CLOSE 2
    290 INPUT#15,EN$,EM$,ET$,ES$
    300 CLOSE 15
    310 END


Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Opens logical file number 2 to device 8 with a secondary address
           | of 2 assigning buffer number 0 ($0300 - $03FF) as a workspace.
160        | Reads the block from drive 0, track 18, sector 0 into channel 2
           | buffer area ($0300 - $03FF).
190        | Begin loop to read 256 bytes ($0300 - $03FF).
200        | Indexed memory-read command ($0300 - $03FF).
210        | Transfer a byte from channel 2 buffer area to C64 memory via the
           | command channel (GET#15,).


The alternate format of the standard memory-read command in line 200 is:

    PRINT#15,"M-R:"CHR$(I)CHR$(3)

Please note that we deliberately omitted the third parameter of the
memory-read command in the preceding example. The following example
incorporates all three parameters of the memory-read command to read a disk
name.


    100 REM THREE PARAMETER MEMORY-READ
    110 OPEN 15,8,15
    120 PRINT#15,"I0"
    130 INPUT#15,EN$,EM$,ET$,ES$
    140 IF EN$<>"00"GOTO 320
    150 OPEN 2,8,2,"#1"
    160 PRINT#15,"U1";2;0;18;0
    170 INPUT#15,EN$,EM$,ET$,ES$
    180 IF EN$<>"00"GOTO 300
    190 PRINT#15,"M-R"CHR$(144)CHR$(4)CHR$(16)
    200 FOR I=1 TO 16
    210 GET#15,B$
    220 IF B$=""THEN B$=CHR$(0)
    230 A=ASC(B$)
    240 IF A>127 THEN A=A-128
    250 IF A<32 OR A>95 THEN A=63
    260 IF A=34 THEN A=63
    270 DN$=DN$+CHR$(A)
    280 NEXT I
    290 PRINT"{DOWN}DISK NAME: ";DN$
    300 CLOSE 2
    310 INPUT#15,EN$,EM$,ET$,ES$
    320 CLOSE 15
    330 END


Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Opens logical file number 2 to device 8 with a secondary
           | address of 2 assigning buffer number 1 ($0400 - $04FF) as a
           | workspace.
160        | Reads the block from drive 0, track 18, sector 0 into channel 2
           | buffer area ($0400 - $04FF).
190        | Memory-read command ($0490 - $049F).
200        | Begin loop to read 16 characters.
210        | Transfer a byte from channel 2 buffer area to C64 memory over
           | the command channel (GET#15,).


Inclusion of the third memory-read parameter means that we no longer have to
issue a memory-read command to fetch each byte like we did in the first
sample program. Instead, we establish a loop after the memory-read command to
pull a byte in. (See lines 200-280 above.) The alternate format of the three
parameter memory-read command in line 190 is:

    PRINT#15,"M-R:"CHR$(144)CHR$(4)CHR$(16)

## 5.7 Memory-Write Command (M-W)

The memory-write command is the opposite of the memory-read command. Data is
written to a DOS buffer via the command channel. The format of a memory-write
command is:

    SYNTAX:
       PRINT# file#, "M-W" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes) data

    ALTERNATE:
       PRINT# file#, "M-W:" CHR$(lo-byte) CHR$(hi-byte) CHR$(# of bytes) data

    EXAMPLE:
        PRINT#15,"M-W"CHR$(2)CHR$(5)CHR$(2)CHR$(1)CHR$(8)
        PRINT#15,"M-W"CHR$(2)CHR$(5)CHR$(2)CHR$(1)D$

where

* file# = the logical file number of the command channel
* lo-byte = lo-byte of the memory address
* hi-byte = hi-byte of the memory address
* # of bytes = 1 to 34
* data = a string variable or a CHR$ iteration

A total of 34 data bytes may be written with each issuance of a memory-write
command. Typically only 8, 16, or 32 data bytes are sent out at one time in a
loop as our buffer size (256 bytes) is evenly divisible by these factors. At
the most sophisticated level of disk programming, machine language programs
can be poked into RAM inside the 1541 with a memory-write command and then
executed. (See Chapter 7 for actual programs of this nature.) In practice,
however, one encounters limited use of the memory-write command.

The following example demonstrates the use of the memory-write command. It
allows you to change the load address of a program file. A routine of this
nature would be used to aid in the disassembly of a program that normally
loads into high memory (e.g., $8000-$BFFF) and is already occupied by a
machine language monitor program (SUPERMON64) or ROM.

    100 REM EDIT LOAD ADDRESS
    110 H$="0123456789ABCDEF"
    120 PRINT"{CLR}EDIT LOAD ADDRESS - 1541"
    130 PRINT"{DOWN}REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
    140 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
    150 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
    160 GETC$:IFC$=""THEN160
    170 IFC$<>CHR$(13)GOTO160
    180 PRINT"OK"
    190 OPEN 15,8,15
    200 PRINT#15,"I0"
    210 INPUT#15,EN$,EM$,ET$,ES$
    220 IFEN$="00"GOTO260
    230 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    240 CLOSE15
    250 END
    260 PRINT#15,"M-R"CHR$(1)CHR$(1)
    270 GET#15,DOS$
    280 IFDOS$=""THENDOS$=CHR$(0)
    290 DOS=ASC(DOS$)
    300 IFDOS=65GOTO330
    310 PRINT"{DOWN}73,CBM DOS V2.6 1541,00,00"
    320 GOTO910
    330 INPUT"{DOWN}FILENAME";F$
    340 IFLEN(F$)<>0ANDLEN(F$)<17GOTO360
    350 GOTO920
    360 OPEN 2,8,2,"0:"+F$+",P,R"
    370 INPUT#15,EN$,EM$,ET$,ES$
    380 IFEN$="00"GOTO400
    390 GOTO940
    400 PRINT#15,"M-R"CHR$(24)CHR$(0)CHR$(2)
    410 GET#15,T$
    420 T=ASC(T$+CHR$(0))
    430 GET#15,S$
    440 S=ASC(S$+CHR$(0))
    450 CLOSE2
    460 INPUT#15,EN$,EM$,ET$,ES$
    470 IFEN$="00"GOTO490
    480 GOTO900
    490 OPEN 2,8,2,"#2"
    500 PRINT#15,"U1";2;0;T;S
    510 INPUT#15,EN$,EM$,ET$,ES$
    520 IFEN$="00"GOTO540
    530 GOTO900
    540 PRINT#15,"M-R"CHR$(2)CHR$(5)CHR$(2)
    550 GET#15,LOW$
    560 LOW=ASC(LOW$+CHR$(0))
    570 GET#15,HIGH$
    580 HIGH=ASC(HIGH$+CHR$(0))
    590 D=HIGH
    600 GOSUB1010
    610 OLA$=HD$
    620 D=LOW
    630 GOSUB1010
    640 OLA$=OLA$+HD$
    650 PRINT"{DOWN}OLD LOAD ADDRESS: ";OLA$
    660 INPUT"{DOWN}NEW LOAD ADDRESS";NLA$
    670 IFLEN(NLA$)=4GOTO690
    680 GOTO960
    690 INPUT"{DOWN}ARE YOU SURE (Y/N)  Y{LEFT 3}";Q$
    700 IFQ$<>"Y"GOTO960
    710 HD$=RIGHT$(NLA$,2)
    720 GOSUB 1060
    730 IFTME=1GOTO960
    740 LOW=D
    750 HD$=LEFT$(NLA$,2)
    760 GOSUB 1060
    770 IFTME=1GOTO960
    780 HIGH=D
    790 PRINT#15,"M-W"CHR$(2)CHR$(5)CHR$(2)CHR$(LOW)CHR$(HIGH)
    800 PRINT#15,"U2";2;0;T;S
    810 INPUT#15,EN$,EM$,ET$,ES$
    820 IFEN$="00"GOTO840
    830 GOTO940
    840 CLOSE2
    850 INPUT#15,EN$,EM$,ET$,ES$
    860 CLOSE15
    870 PRINT"{DOWN}DONE!"
    880 END
    890 REM CLOSE
    900 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    910 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    920 CLOSE15
    930 END
    940 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
    950 PRINT"{DOWN}{RVS}FAILED{ROFF}"
    960 CLOSE2
    970 INPUT#15,EN$,EM$,ET$,ES$
    980 CLOSE15
    990 END
    1000 REM DECIMAL TO HEXADECIMAL
    1010 H=INT(D/16)
    1020 L=D-(H*16)
    1030 HD$=MID$(H$,H+1,1)+MID$(H$,L+1,1)
    1040 RETURN
    1050 REM HEXADECIMAL TO DECIMAL
    1060 TME=0
    1070 H=0
    1080 FORI=1TO16
    1090 IFLEFT$(HD$,1)=MID$(H$,I,1)THENH=I:I = 16
    1100 NEXTI
    1110 IFH=0THENTME=1:GOTO1200
    1120 H=H-1
    1130 L=0
    1140 FORI=1TO16
    1150 IFRIGHT$(HD$,1)=MID$(H$,I,1)THENL=I:I=16
    1160 NEXTI
    1170 IFL=0THENTME=1:GOTO1200
    1180 L=L-1
    1190 D=H*16+L
    1200 RETURN



Line Range | Description
:--------- |:----------------------------------------------------------------
260-320    | Query DOS version ($0101).
330-350    | Input file name.
360-390    | Opens logical file number 2 to device 8 with a secondary address
           | of 2 for a program read.
400-440    | Fetch file name track ($0018) and sector ($0019).
450        | Close logical file number 2.
490        | Reopens logical file number 2 to device 8 with a secondary
           | address of 2 assigning buffer number 2 ($0500 - $05FF) as a
           | workspace.
500        | Reads the starting block of the filename from drive 0 as
           | specified by $0018 and $0019 into channel 2 buffer area ($0500 -
           | $05FF).
540        | Three parameter memory-read command to fetch two byte load
           | address ($0502 - $0503).
550        | Fetch lo-byte of load address ($0502).
570        | Fetch hi-byte of load address ($0503).
590-640    | Decimal to hexadecimal conversion of load address.
660-700    | Input new load address.
710-780    | Hexadecimal to decimal conversion of new load address.
790        | Memory-write of new two byte load address ($0502 - $0503).
800        | Write channel 2 buffer ($0500 - $05FF) to drive 0, track
           | ($0018), sector ($0019).


The alternate format of the memory-write command in line 790 is:

    PRINT#15,"M-W:"CHR$(2)CHR$(5)CHR$(2)CHR$(LO)CHR$(HI)

## 5.8 Block-Allocate Command (B-A)

The block-allocate command allocates a sector in the BAM as in use. A sector
is allocated by setting its associated bit low (0) on track 18, sector 0.
(Review the coverage on bit mapping in Chapter 4 if necessary.) The DOS will
not write to an allocated sector during a normal write operation such as a
SAVE. However, an allocated sector can be overwritten with a block-write
command (U2). Hence the origin of the term "direct-access."

The format of a block-allocate command is:

    SYNTAX:
        PRINT# file#, "B-A"; drive#; track; sector

    ALTERNATE:
        PRINT# file#, "B-A:"; drive#; track; sector

    EXAMPLE:
        PRINT#15,"B-A";0;1;7

where

* file# = the logical file number of the command channel
* drive# = 0
* track = 1 to 35
* sector = 0 to the range for a given track

The following program allocates every sector on a diskette. Run this program
on a test diskette.

100 REM BLOCK-ALLOCATE
110 OPEN 15,8,15
120 PRINT#15,"I0"
130 INPUT#15,EN$,EM$,ET$,ES$
140 IF EN$<>"00"GOTO 310
150 OPEN 2,8,2,"#"
160 T=1
170 S=0
180 PRINT#15,"B-A";0;T;S
190 INPUT#15,EN$,EM$,ET$,ES$
200 IF EN$="00"GOTO 180
210 IF EN$<>"65"GOTO 330
220 BA=BA+1
230 PRINT T,S,BA
240 T=VAL(ET$)
250 IF T=0 GOTO 290
260 IF T=18 THEN T=19:S=0:GOTO 180
270 S=VAL(ES$)
280 GOTO 180
290 CLOSE 2
300 INPUT#15,EN$,EM$,ET$,ES$
310 CLOSE 15
320 END
330 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
340 CLOSE 2
350 INPUT#15,EN$,EM$,ET$,ES$
360 CLOSE 15
370 END


Line Range | Description
:--------- |:----------------------------------------------------------------
150        | Open a direct-access channel.
160        | Initialize track to 1.
170        | Initialize sector to 0.
180        | Block-allocate command.
190        | Query error channel.
200        | The track and sector were not allocated.
210        | Something is amiss so bail out.
220        | Counter representing the number of sectors allocated in line
           | 170.
230        | Print track, sector, counter.
240        | The sector just allocated already was but the DOS returns the
           | next available track in the error message (65, NO BLOCK, track,
           | sector).
250        | If the next available track is zero then all 683 blocks on the
           | diskette have been allocated.
260        | Don't allocate the directory.
270        | The DOS returns the next available sector in the error message
           | (65, NO BLOCK, track, sector).
280        | Allocate the next available track and sector.
290        | Close the direct-access channel.
330-370    | Error handler.


The alternate format of the block-allocate command in line 180 is:

    PRINT#15,"B-A:";0;T;S

The opening of a direct-access channel (line 150) is standard form. Why?
Because the BAM is rewritten to a diskette when a direct-access data channel
is closed (line 290).

In reality, though, the BAM is updated on the fly but very erratically. Thus,
opening and closing a direct-access data channel is a good habit to get into.
An ounce of prevention . . .

By the way, what happens when you try to save to a full disk? Error 72, DISK
FULL right? Would you believe error 67, ILLEGAL TRACK OR SECTOR,36,01? Track
36? That's right. An error 72 only occurs during normal write mode (i.e., not
a direct-access write) where at least 1 free block exists at the outset or
the directory is at its physical limit, i.e., 144 active file entries.

A block remains allocated until a diskette is validated. Unless a given track
and sector somehow chains to a directory entry its bit will be freed (1)
during validation. (See the validate command in Chapter 2.) Caution must be
taken to ensure that the block-allocate command does not allocate an unused
sector in the directory. See line 260 above. Once a sector has been allocated
in the directory, it is never deallocated by the DOS, even during a validate.
An allocated directory sector can only be freed under software control.

The following program makes use of the block-allocate command to certify a
formatted diskette. A worst-case binary pattern is written to any sector not
currently in use. Bad sectors, if any, are allocated in the BAM. However,
these bad sectors will be deallocated if the diskette is ever validated.
(Sorry, but that's the nature of the beast.)

100 REM CERTIFY A DISKETTE - 1541
110 FORI=1TO32
120 NULL$=NULL$+CHR$(0)
130 WRITE$=WRITE$+CHR$(15)
140 NEXTI
150 DIMT%(681),S%(681)
160 PRINT"{CLR}           CERTIFY A DISKETTE"
170 PRINT"{DOWN}                {RVS}WARNING{ROFF}"
180 PRINT"{DOWN}{RVS}RANDOM ACCESS{ROFF} AND {RVS}DEL{ROFF} FILES WILL BE LOST"
190 PRINT"REMOVE {RVS}WRITE PROTECT TAB{ROFF}"
200 PRINT"{DOWN}INSERT DISKETTE IN DRIVE"
210 PRINT"{DOWN}PRESS {RVS}RETURN{ROFF} TO CONTINUE"
220 GETC$:IFC$=""THEN220
230 IFC$<>CHR$(13)GOTO220
240 PRINT"OK"
250 OPEN 15,8,15
260 PRINT#15,"I0"
270 INPUT#15,EN$,EM$,ET$,ES$
280 IFEN$="00"GOTO33O
290 PRINT"{DOWN}"EN$", "EM$","ET$","ES$
300 CLOSE15
310 END

91

-----------------------------------------------------Page 91-----------------------------------------------------
